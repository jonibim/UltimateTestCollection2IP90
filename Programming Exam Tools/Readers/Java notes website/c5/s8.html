<html>
<head>
    <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Javanotes 7.0, Section 5.8 -- Nested Classes</title>
    <link type="text/css" rel="stylesheet" href="../javanotes.css">
</head>
<body>
<div align="right">
    <small>
        [ <a href="s7.html">Previous Section</a> |
        <a href="index.html">Chapter Index</a> |
        <a href="../index.html">Main Index</a> ]
    </small>
</div>
<hr>
<table class="subsections" vspace="8" hspace="8" cellpadding="5" border="2" align="right">
    <tr>
        <td>
            <div align="center">
                <b>Subsections</b>
                <hr>
                <small><a href="#OOP.8.1">Static Nested Classes</a>
                    <br>
                    <a href="#OOP.8.2">Inner Classes</a>
                    <br>
                    <a href="#OOP.8.3">Anonymous Inner Classes</a>
                    <br>
                    <a href="#OOP.8.4">Java 8 Lambda Expressions</a>
                    <br>
                </small>
            </div>
        </td>
    </tr>
</table>
<div class="content">
    <h3 class="section_title">Section 5.8</h3>
    <h2 class="section_title">Nested Classes</h2>
    <hr class="break">


    <p>
        <span class="start"><big>A</big> class seems like it should be</span> a pretty important thing. A class is a
        high-level building block of a program, representing a potentially complex idea
        and its associated data and behaviors. I've always felt a bit silly writing
        tiny little classes that exist only to group a few scraps of data together.
        However, such trivial classes are often useful and even essential. Fortunately,
        in Java, I can ease the embarrassment, because one class can be nested inside
        another class. My trivial little class doesn't have to stand on its own. It
        becomes part of a larger more respectable class. This is particularly useful
        when you want to create a little class specifically to support the work of a
        larger class. And, more seriously, there are other good reasons for nesting the
        definition of one class inside another class.</p>


    <p>In Java, a <span class="newword">nested class</span> is any class whose definition is inside the
        definition of another class. (In fact, a class can even be nested inside a subroutine,
        which must, of course, itself be inside a class).
        Nested classes can be either <span class="newword">named</span>
        or <span class="newword">anonymous</span>. I will come
        back to the topic of anonymous classes later in this section. A named nested
        class, like most other things that occur in classes, can be either static or
        non-static.</p>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="OOP.8.1">5.8.1&nbsp;&nbsp;Static Nested Classes</a>
    </h3>


    <p>The definition of a static nested class looks just like the definition of any other class,
        except that it is nested inside another class and it has the modifier <span class="code">static</span>
        as part of its declaration. A static nested class is part of the static structure of the
        containing class. It can be used inside that class to create objects in the
        usual way. If it is used
        outside the containing class, its name
        must indicate its membership in the containing class. That is, the full name of
        the static nested class consists of the name of the class in which it is nested, followed
        by a period, followed by the name of the nested class. This is similar to other
        static components of a class: A static nested class is part of the class itself
        in the same way that static member variables are parts of the class itself.</p>


    <p>For example, suppose a class named <span class="classname">WireFrameModel</span> represents a set
        of lines in three-dimensional space. (Such models are used to represent
        three-dimensional objects in graphics programs.) Suppose that the
        <span class="classname">WireFrameModel</span> class contains a static nested class, <span
                class="classname">Line</span>,
        that represents a single line. Then, outside of the class
        <span class="classname">WireFrameModel</span>, the <span class="classname">Line</span> class would be referred
        to as
        <span class="code">WireFrameModel.Line</span>. Of course, this just follows the normal naming
        convention for static members of a class. The definition of the
        <span class="classname">WireFrameModel</span> class with its nested <span class="classname">Line</span> class
        would look,
        in outline, like this:</p>


    <pre>public class WireFrameModel {

   . . . // other members of the WireFrameModel class
   
   static public class Line {
         // Represents a line from the point (x1,y1,z1)
         // to the point (x2,y2,z2) in 3-dimensional space.
      double x1, y1, z1;
      double x2, y2, z2;
   } // end class Line
   
   . . . // other members of the WireFrameModel class
   
} // end WireFrameModel</pre>


    <p>The full name of the nested class is <span class="classname">WireFrameModel.Line</span>.
        That name can be used, for example, to declare variables.
        Inside the <span class="classname">WireFrameModel</span> class, a <span class="classname">Line</span> object
        would be
        created with the constructor "<span class="code">new&nbsp;Line()</span>". Outside the class,
        "<span class="code">new&nbsp;WireFrameModel.Line()</span>" would be used.</p>


    <p>A static nested class has full access to the static members of the containing
        class, even to the <span class="code">private</span> members. Similarly, the containing class has full
        access to the members of the nested class, even if they are marked <span class="code">private</span>.
        This can be another motivation for
        declaring a nested class, since it lets you give one class access to the
        private members of another class without making those members generally
        available to other classes. Note also that a nested class can itself be private,
        meaning that it can only be used inside the class in which it is nested.</p>


    <p>When you compile the above class definition, two class files will be
        created. Even though the definition of <span class="classname">Line</span> is nested inside
        <span class="classname">WireFrameModel</span>, the compiled <span class="classname">Line</span> class is stored
        in a
        separate file. The name of the class file for <span class="classname">Line</span> will be
        <span class="code">WireFrameModel$Line.class</span>.</p>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="OOP.8.2">5.8.2&nbsp;&nbsp;Inner Classes</a>
    </h3>


    <p>Non-static nested classes are referred to as <span class="newword">inner classes</span>.
        Inner classes are not, in practice, very different from static
        nested classes, but a non-static nested class is actually associated with an
        object rather than with the class in which its definition is nested. This can take some
        getting used to.</p>


    <p>Any non-static member of a class is not really part of the class itself
        (although its source code is contained in the class definition). This is true
        for inner classes, just as it is for any other non-static part of a
        class. The non-static members of a class specify what will be contained in
        objects that are created from that class. The same is true -- at least
        logically -- for inner classes. It's as if each object that belongs
        to the containing class has its <b>own copy</b> of the nested class (although it does not
        literally contain a copy of the compiled code for the nested class). This copy
        has access to all the instance methods and instance variables of the object,
        even to those that are declared <span class="code">private</span>.
        The two copies of the inner class in two different objects differ because the instance
        variables and methods they refer to are in different objects. In fact, the rule
        for deciding whether a nested class should be static or non-static is simple:
        If the nested class needs to use any instance variable or instance method
        from the containing class, make the nested class
        non-static. Otherwise, it might as well be static.</p>


    <p>In most cases, an inner class is used only within the class where it is
        defined. When that is true, using the inner class is really not much different from
        using any other class. You can create variables and declare objects using the
        simple name of the inner class in the usual way.</p>


    <p>From outside the containing class, however, an inner class has to be
        referred to using a name of the form <span class="bnf">variableName</span>.<span
                class="bnf">NestedClassName</span>,
        where <span class="bnf">variableName</span> is a variable that refers to the object that
        contains the inner class. In order to create an object that belongs to an inner class, you
        must first have an object that belongs to the containing class. (When working
        inside the class, the object "<span class="code">this</span>" is used implicitly.)</p>


    <p>Looking at
        an example will help, and will hopefully convince you that inner
        classes are really very natural. Consider a class that represents poker games.
        This class might include a nested class to represent the players of the game.
        The structure of the <span class="classname">PokerGame</span> class could be:</p>


    <pre>public class PokerGame {  // Represents a game of poker.
    
    class Player {  // Represents one of the players in <u>this</u> game.
       .
       .
       .
    } // end class Player
    
    private Deck deck;      // A deck of cards for playing the game.
    private int pot;        // The amount of money that has been bet.
    
    .
    .
    .

} // end class PokerGame</pre>


    <p>If <span class="code">game</span> is a variable of type <span class="classname">PokerGame</span>, then,
        conceptually, <span class="code">game</span> contains its own copy of the <span class="classname">Player</span>
        class.
        In an instance method of a <span class="classname">PokerGame</span> object, a new <span
                class="classname">Player</span>
        object would be created by saying "<span class="code">new&nbsp;Player()</span>", just as for any
        other class. (A <span class="classname">Player</span> object could be created outside the
        <span class="classname">PokerGame</span> class with an expression such as
        "<span class="code">game.new&nbsp;Player()</span>". Again, however, this is rare.)
        The <span class="classname">Player</span>
        object will have access to the <span class="code">deck</span> and <span class="code">pot</span> instance
        variables in the <span class="classname">PokerGame</span> object. Each <span class="code">PokerGame</span>
        object has
        its own <span class="code">deck</span> and <span class="code">pot</span> and <span class="code">Players</span>.
        Players of that
        poker game use the deck and pot for that game; players of another poker game use
        the other game's deck and pot. That's the effect of making the <span class="classname">Player</span>
        class non-static. This is the most natural way for players to behave. A
        <span class="classname">Player</span> object represents a player of one particular poker game. If
        <span class="classname">Player</span> were an independent class or a <b>static</b> nested class,
        on the other hand, it would represent the general idea of a poker player, independent of a
        particular poker game.</p>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="OOP.8.3">5.8.3&nbsp;&nbsp;Anonymous Inner Classes</a>
    </h3>


    <p>In some cases, you might find yourself writing an inner class and then using
        that class in just a single line of your program. Is it worth creating such a
        class? Indeed, it can be, but for cases like this you have the option of using
        an <span class="newword">anonymous inner class</span>. An anonymous class is
        created with a variation of the <span class="code">new</span> operator that has the form</p>


    <pre>
          new  <span class="bnf">superclass-or-interface</span> ( <span class="bnf">parameter-list</span> ) {
                   <span class="bnf">methods-and-variables</span>
              }
</pre>


    <p>This constructor defines a new class, without giving it a name, and it
        simultaneously creates an object that belongs to that class. This form of the
        <span class="code">new</span> operator can be used in any statement where a regular
        "<span class="code">new</span>" could be used. The intention of this expression is to create: "a
        new object belonging to a class that is the same as <span class="bnf">superclass-or-interface</span>
        but with these <span class="bnf">methods-and-variables</span> added."
        The effect is to create a uniquely customized object, just at the point in the program where you need it.
        Note that it is possible to base an anonymous class on an interface, rather
        than a class. In this case, the anonymous class must implement the interface by
        defining all the methods that are declared in the interface. If an interface
        is used as a base, the <span class="bnf">parameter-list</span> must be empty. Otherwise, it can contain
        parameters for a constructor in the <span class="bnf">superclass</span>.</p>


    <p>Anonymous classes are often used for handling events in graphical user
        interfaces, and we will encounter them several times in the chapters on GUI programming.
        For now, we will look at one not-very-plausible example. Consider the
        <span class="classname">Drawable</span> interface, which is defined earlier in this section. Suppose
        that we want a <span class="classname">Drawable</span> object that draws a filled, red, 100-pixel
        square. Rather than defining a new, separate class and then using that class to
        create the object, we can use an anonymous class to create the object in one
        statement:</p>


    <pre>Drawable redSquare = <span class="newcode">new Drawable() {
       void draw(Graphics g) {
          g.setColor(Color.RED);
          g.fillRect(10,10,100,100);
       }
   }</span>;</pre>


    <p>Then <span class="code">redSquare</span> refers to an object that implements <span
            class="classname">Drawable</span>
        and that draws a red square when its <span class="code">draw()</span> method is called.
        By the way, the semicolon at the end of the statement is not part of the class
        definition; it's the semicolon that is required at the end of every declaration
        statement.</p>


    <p>Anonymous classes are often used for actual parameters. For example, consider the
        following simple method, which draws a <span class="classname">Drawable</span> in two different graphics
        contexts:</p>


    <pre>void drawTwice( Graphics g1, Graphics g2, Drawable figure ) {
    figure.draw(g1);
    figure.draw(g2);
}</pre>


    <p>When calling this method, the third parameter can be created using an anonymous inner class.
        For example:</p>


    <pre>drawTwice( firstG, secondG, <span class="newcode">new Drawable() {
          void draw(Graphics g) {
             g.drawOval(10,10,100,100);
          }
     }</span> );</pre>


    <p>When a Java class is compiled, each anonymous nested class will produce a
        separate class file. If the name of the main class is <span class="code">MainClass</span>, for
        example, then the names of the class files for the anonymous nested classes
        will be <span class="code">MainClass$1.class</span>, <span class="code">MainClass$2.class</span>,
        <span class="code">MainClass$3.class</span>, and so on.</p>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="OOP.8.4">5.8.4&nbsp;&nbsp;Java 8 Lambda Expressions</a>
    </h3>


    <p>The syntax for anonymous classes is cumbersome. In many cases, an anonymous class
        implements an interface that defines just one method. Java&nbsp;8 introduces a new
        syntax that can be used in place of the anonymous class in that circumstance:
        the lambda expression. Here is what the previous subroutine call looks like using a
        lambda expression:</p>


    <pre>drawTwice( firstG, secondG, <span class="newcode">g -&gt; g.drawOval(10,10,100,100)</span> )</pre>


    <p>The lambda expression is <span class="code">g -&gt; g.drawOval(10,10,100,100)</span>. Its meaning
        is, "the method that has a parameter <span class="code">g</span> and executes the code
        <span class="code">g.drawOval(10,10,100,100)</span>."
        The computer knows that <span class="code">g</span>
        is of type <span class="classname">Graphics</span> because it is expecting a
        <span class="classname">Drawable</span> as the actual parameter, and the only method in
        the <span class="classname">Drawable</span> interface has a parameter of type
        <span class="classname">Graphics</span>. Lambda expressions can only be used in places where
        this kind of type inference can be made. The general syntax of a lambda expression is</p>


    <pre>
<span class="bnf">formal-parameter-list</span>  -&gt;  <span class="bnf">method-body</span>
</pre>


    <p>where the <span class="bnf">method body</span> can be a single expression, a single subroutine call,
        or a block of statements enclosed between
        <span class="code">{</span>&nbsp;and&nbsp;<span class="code">}</span>. When the body is a single expression or
        function call, the
        value of the expression is automatically used as the return value of the method that
        is being defined.
        The parameter list in the lambda expression does not have to specify the types of the
        parameters, although it can. Parentheses around the parameter list are optional if there is exactly one
        parameter and no type is specified for the parameter; this is the form seen in the example above.
        For a method with no parameters, the parameter list is just an empty set of parentheses. Here
        are a few more examples of lambda expressions:</p>


    <pre>() -&gt; System.out.println("Hello World")

g -&gt; { g.setColor(Color.RED); g.drawRect(10,10,100,100); }

(a, b) -&gt; a + b

(int n) -&gt; { 
         while (n &gt; 0) { 
             System.out.println(n); 
             n = n/2; 
          } 
      } // lambda expressions ends here
</pre>


    <p>As you can see, the syntax can still get pretty complicated. There is quite a lot
        more to say about lambda expressions, but my intention here is only to briefly introduce
        one of the most interesting new features in Java&nbsp;8.</p>


    <hr>
    <div align="center">
        <b><small>End of Chapter 5</small></b>
    </div>
    <hr>


</div>
<hr>
<div align="right">
    <small>
        [ <a href="s7.html">Previous Section</a> |
        <a href="index.html">Chapter Index</a> |
        <a href="../index.html">Main Index</a> ]
    </small>
</div>
</body>
</html>
