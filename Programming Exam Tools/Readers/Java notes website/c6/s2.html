<html>
<head>
    <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Javanotes 7.0, Section 6.2 -- Graphics and Painting</title>
    <link type="text/css" rel="stylesheet" href="../javanotes.css">
</head>
<body>
<div align="right">
    <small>
        [ <a href="s1.html">Previous Section</a> |
        <a href="s3.html">Next Section</a> |
        <a href="index.html">Chapter Index</a> |
        <a href="../index.html">Main Index</a> ]
    </small>
</div>
<hr>
<table class="subsections" vspace="8" hspace="8" cellpadding="5" border="2" align="right">
    <tr>
        <td>
            <div align="center">
                <b>Subsections</b>
                <hr>
                <small><a href="#GUI1.3.1">Coordinates</a>
                    <br>
                    <a href="#GUI1.3.2">Colors</a>
                    <br>
                    <a href="#GUI1.3.3">Fonts</a>
                    <br>
                    <a href="#GUI1.3.4">Shapes</a>
                    <br>
                    <a href="#GUI1.3.5">Graphics2D</a>
                    <br>
                    <a href="#GUI1.3.6">An Example</a>
                    <br>
                    <a href="#GUI1.3.7">Where is main()?</a>
                    <br>
                </small>
            </div>
        </td>
    </tr>
</table>
<div class="content">
    <h3 class="section_title">Section 6.2</h3>
    <h2 class="section_title">Graphics and Painting</h2>
    <hr class="break">


    <p>
        <span class="start"><big>E</big>verything you see on a computer screen</span> has to be
        drawn there, even the text. The Java API includes a range of classes and
        methods that are devoted to drawing. In this section, I'll look at some of the
        most basic of these. Some of this material was already covered in preliminary
        form in <a href="../c3/s9.html">Section&nbsp;3.9</a>.</p>


    <p>The physical structure of a GUI is built of components. The term <span class="newword">component</span>
        refers to a visual element in a GUI, including buttons, menus, text-input boxes, scroll bars,
        check boxes, and so on. In Java,
        GUI components are represented by objects belonging to subclasses of the class
        <span class="code">java.awt.Component</span>. Most components in the Swing GUI toolkit -- although not
        top-level components like JFrame -- belong to subclasses of the class
        <span class="code">javax.swing.JComponent</span>, which is itself a subclass of <span class="code">java.awt.Component</span>.
        Every component is responsible for drawing
        itself. If you want to use a standard component, you only have to
        add it to your program. You don't have to worry about painting it on the screen.
        That will happen automatically, since it already knows how to draw itself.</p>


    <p>Sometimes, however, you do want to draw on a component. You will have to do
        this whenever you want to display something that is not included among the
        standard, pre-defined component classes. When you want to do this, you have to
        define your own component class and provide a method in that class for drawing
        the component. I will always use a subclass of <span class="classname">JPanel</span>
        when I need a drawing surface of this kind, as I did for the
        <span class="classname">HelloWorldDisplay</span> class in the example
        <span class="sourceref"><a href="../source/chapter6/HelloWorldGUI2.java">HelloWorldGUI2.java</a></span> in the
        <a href="../c6/s1.html">previous section</a>.
        A JPanel, like any JComponent, draws its content in the method</p>


    <pre>public void paintComponent(Graphics g)</pre>


    <p>To create a drawing surface, you should define a subclass of <span class="code">JPanel</span>
        and provide a custom <span class="code">paintComponent()</span> method. Create an object
        belonging to this class and use it in your program. When the time comes
        for your component to be drawn on the screen, the system will call its
        <span class="code">paintComponent()</span> to do the drawing. That is, the code that you put
        into the <span class="code">paintComponent()</span> method will be executed whenever the
        panel needs to be drawn on the screen; by writing this method, you determine
        the picture that will be displayed in the panel. Note that you are not likely to
        call a <span class="code">paintComponent()</span> method any more than you are likely to call
        a <span class="code">main()</span> routine. The <i>system</i> calls the method. You <i>write</i>
        the method to say what will happen when the system calls it.</p>


    <p>Note that the <span class="code">paintComponent()</span> method has a parameter of type
        <span class="classname">Graphics</span>. The <span class="classname">Graphics</span> object will be provided by
        the system
        when it calls your method. You need this object to do the actual drawing. To do
        any drawing at all in Java, you need a <span class="newword">graphics context</span>.
        A graphics context is an object belonging to the class
        <span class="code">java.awt.Graphics</span>. Instance methods are provided in this class for
        drawing shapes, text, and images. Any given <span class="classname">Graphics</span> object can draw
        to only one location. In this chapter, that location will always be a GUI
        component belonging to some subclass of <span class="code">JPanel</span>. The
        <span class="classname">Graphics</span> class is an abstract class, which means that it is impossible
        to create a graphics context directly, with a constructor. There are actually
        two ways to get a graphics context for drawing on a component: First of all, of
        course, when the <span class="code">paintComponent()</span> method of a component is called by
        the system, the parameter to that method is a graphics context for drawing on
        the component. Second, every component has an instance method called
        <span class="code">getGraphics()</span>. This method is a function that returns a graphics
        context that can be used for drawing on the component outside its
        <span class="code">paintComponent()</span> method. The official line is that you should
        <b>not</b> do this, and I will almost always avoid it. But I have
        found it convenient to use <span class="code">getGraphics()</span> in a few examples.
        (Note that if <span class="code">g</span> is a graphics context created with <span
                class="code">getGraphics()</span>,
        it is good form to call <span class="code">g.dispose()</span> when finished using it. This
        releases any operating system resources that might be held by&nbsp;<span class="code">g</span>.)</p>


    <p>The <span class="code">paintComponent()</span> method in the <span class="classname">JPanel</span>
        class simply fills the panel with the panel's background color. When defining a
        subclass of <span class="classname">JPanel</span> for use as a drawing surface, you will
        usually want to fill the panel with the background color before drawing
        other content onto the panel (although it is not necessary to do this if the drawing
        commands in the method cover the background of the component completely).
        This is traditionally done with a call to
        <span class="code">super.paintComponent(g)</span>, so most <span class="code">paintComponent()</span>
        methods that you write will have the form:</p>


    <pre>public void paintComponent(g) {
   super.paintComponent(g);
   . . . // Draw the content of the component.
}</pre>


    <hr class="break">


    <p>In general, a component should do all drawing operations in its
        <span class="code">paintComponent()</span> method. What happens if, in the middle of some other
        method, you realize that the content of the component needs to be changed? You
        should <b>not</b> call <span class="code">paintComponent()</span> directly to make the
        change. Instead, you have
        to inform the system that the component needs to be redrawn, and let the system
        do its job by calling <span class="code">paintComponent()</span>. You do this by calling the
        component's <span class="code">repaint()</span> method. The method</p>


    <pre>public void repaint();</pre>


    <p>is defined in the <span class="code">Component</span> class, and so can be used with any
        component. You should call <span class="code">repaint()</span> to inform the system that the
        component needs to be redrawn. It is important to understand that the
        <span class="code">repaint()</span> method returns
        immediately, without doing any painting itself. The system will call the
        component's <span class="code">paintComponent()</span> method <i>later</i>, as soon as it gets
        a chance to do so, after processing other pending events if there are any.
        It is even possible that many calls to <span class="code">repaint()</span> will all be handled
        by one call to <span class="code">paintComponent()</span>, if the calls to <span class="code">repaint()</span>
        occur in a very short timespan.</p>


    <p>Note that the system can also call <span class="code">paintComponent()</span> for other
        reasons. It is called when the component first appears on the screen. It will
        also be called if the size of the component changes, which can happen when
        the user resizes the window that contains the component. This means that
        <span class="code">paintComponent()</span> should be capable of redrawing the content
        of the component on demand. As you will see, however, some of our early examples
        will not be able to do this correctly.</p>


    <p>This means that, to work properly, the <span class="code">paintComponent()</span> method must
        be smart enough to correctly redraw the component at any time. To make this
        possible, a program should store data in its instance variables
        about the state of the component. These variables should contain all the information
        necessary to redraw the component completely. The <span class="code">paintComponent()</span>
        method should use the data in these variables to decide what to draw. When the
        program wants to change the content of the component, it should not simply draw
        the new content. It should change the values of the relevant variables and call
        <span class="code">repaint()</span>. When the system calls <span class="code">paintComponent()</span>, that
        method will use the new values of the variables and will draw the component
        with the desired modifications. This might seem a roundabout way of doing
        things. Why not just draw the modifications directly? There are at least two
        reasons. First of all, it really does turn out to be easier to get things right
        if all drawing is done in one method. Second, even if you could directly
        draw the modifications, you would still have to save enough information about
        the modifications to enable <span class="code">paintComponent()</span>
        to <b>redraw</b> the component correctly on demand.</p>


    <p>You will see how all this works in practice as we work through examples in
        the rest of this chapter. For now, we will spend the rest of this section
        looking at how to get some actual drawing done.</p>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="GUI1.3.1">6.2.1&nbsp;&nbsp;Coordinates</a>
    </h3>


    <p>The screen of a computer is a grid of little squares called <span class="newword">pixels</span>.
        The color of each pixel can be set individually, and
        drawing on the screen just means setting the colors of individual pixels.</p>


    <p align="center">
        <img src="pixel-coordinates.png" width="420" height="212" alt="pixel coordinate system" class="bordered"></p>


    <p>A graphics context draws in a rectangle made up of pixels. A position in the
        rectangle is specified by a pair of integer coordinates, <span class="code">(x,y)</span>. The
        upper left corner has coordinates <span class="code">(0,0)</span>. The <span class="code">x</span> coordinate
        increases from left to right, and the <span class="code">y</span> coordinate increases from top
        to bottom. The illustration shows a 20-pixel by 12-pixel component (with
        very large pixels). A small line, rectangle, and oval are shown as they would
        be drawn by coloring individual pixels. (Note that, properly speaking, the
        coordinates don't belong to the pixels but to the grid lines between them.)</p>


    <p>For any component, you can find out the size of the rectangle that it
        occupies by calling the instance methods <span class="code">getWidth()</span> and
        <span class="code">getHeight()</span>, which return the number of pixels in the
        horizontal and vertical directions, respectively. In general, it's not
        a good idea to assume that you know the size of a component, since the
        size is often set by a layout manager and can even change if the component
        is in a window and that window is resized by the user. This means that it's good
        form to check the size of a component before doing any drawing on that
        component. For example, you can use a <span class="code">paintComponent()</span> method that
        looks like:</p>


    <pre>public void paintComponent(Graphics g) {
   super.paintComponent(g);
   int width =  getWidth();   // Find out the width of this component.
   int height = getHeight();  // Find out its height.
   . . .   // Draw the content of the component.
}</pre>


    <p>Of course, your drawing commands will have to take the size into account.
        That is, they will have to use <span class="code">(x,y)</span> coordinates that are calculated
        based on the actual height and width of the component. (However, if you are
        sure that you know the size, using constants for the width and height can
        make the drawing easier.)</p>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="GUI1.3.2">6.2.2&nbsp;&nbsp;Colors</a>
    </h3>


    <p>You will probably want to use some color when you draw.
        Java is designed to work with the <span class="newword">RGB color system</span>.
        An RGB color is specified by three numbers that give the level
        of red, green, and blue, respectively, in the color. A color in Java is an
        object of the class, <span class="code">java.awt.Color</span>. You can construct a new color by
        specifying its red, blue, and green components. For example,</p>


    <pre>Color myColor = new Color(r,g,b);</pre>


    <p>There are two constructors that you can call in this way. In the one that I
        almost always use, <span class="code">r</span>, <span class="code">g</span>, and <span class="code">b</span> are
        integers in the
        range 0 to 255. In the other, they are numbers of type <span class="ptype">float</span> in the
        range 0.0F to 1.0F. (Recall that a literal of type <span class="ptype">float</span> is
        written with an "F" to distinguish it from a <span class="ptype">double</span> number.) Often,
        you can avoid constructing new colors altogether, since the <span class="classname">Color</span>
        class defines several named constants representing common colors: <span class="code">Color.WHITE</span>,
        <span class="code">Color.BLACK</span>, <span class="code">Color.RED</span>, <span
                class="code">Color.GREEN</span>,
        <span class="code">Color.BLUE</span>, <span class="code">Color.CYAN</span>, <span
                class="code">Color.MAGENTA</span>,
        <span class="code">Color.YELLOW</span>, <span class="code">Color.PINK</span>, <span
                class="code">Color.ORANGE</span>,
        <span class="code">Color.LIGHT_GRAY</span>, <span class="code">Color.GRAY</span>, and <span class="code">Color.DARK_GRAY</span>.
        (There are older, alternative names for these constants that use lower case rather than
        upper case constants, such as <span class="code">Color.red</span> instead of <span class="code">Color.RED</span>,
        but the upper case versions are preferred because they follow the convention that
        constant names should be upper case.)</p>


    <p>An alternative to RGB is the <span class="newword">HSB color system</span>.
        In the HSB system, a color is specified by three numbers called the
        <span class="newword">hue</span>, the <span class="newword">saturation</span>,
        and the <span class="newword">brightness</span>. The hue is the basic color,
        ranging from red through orange through all the other colors of the rainbow.
        The brightness is pretty much what it sounds like. A fully saturated color is a
        pure color tone. Decreasing the saturation is like mixing white or gray paint
        into the pure color. In Java, the hue, saturation and brightness are always
        specified by values of type <span class="ptype">float</span> in the range from 0.0F to 1.0F. The
        <span class="classname">Color</span> class has a <span class="code">static</span> member function named
        <span class="code">getHSBColor</span> for creating HSB colors. To create the color with HSB
        values given by <span class="code">h</span>, <span class="code">s</span>, and <span class="code">b</span>, you
        can say:</p>


    <pre>Color myColor = Color.getHSBColor(h,s,b);</pre>


    <p>For example, to make a color with a random hue that is as bright and as
        saturated as possible, you could use:</p>


    <pre>Color randomColor = Color.getHSBColor( (float)Math.random(), 1.0F, 1.0F );</pre>


    <p>The type cast is necessary because the value returned by
        <span class="code">Math.random()</span> is of type <span class="ptype">double</span>, and
        <span class="code">Color.getHSBColor()</span> requires values of type <span class="ptype">float</span>. (By the
        way, you might ask why RGB colors are created using a constructor while HSB
        colors are created using a static member function. The problem is that we would
        need two different constructors, both of them with three parameters of type
        <span class="ptype">float</span>. Unfortunately, this is impossible. You can have two
        constructors only if the number of parameters or the parameter types differ.)</p>


    <p>The RGB system and the HSB system are just different ways of describing the
        same set of colors. It is possible to translate between one system and the
        other. The best way to understand the color systems is to experiment with them.
        (The sample program <span class="sourceref"><a href="../source/chapter6/SimpleColorChooser.java">SimpleColorChooser.java</a></span>
        lets you do that.
        You won't understand the source code at this time, but you can run it to play
        with color selection or to find the RGB or HSB values for the color that want.)</p>


    <hr class="break">


    <p>One of the properties of a <span class="classname">Graphics</span> object is the current
        drawing color, which is used for all drawing of shapes and text. If <span class="code">g</span>
        is a graphics context, you can change the current drawing color for <span class="code">g</span>
        using the method <span class="code">g.setColor(c)</span>, where <span class="code">c</span> is a <span
                class="classname">Color</span>.
        For example, if you want to draw in green, you would just say
        <span class="code">g.setColor(Color.GREEN)</span> before doing the drawing. The graphics context
        continues to use the color until you explicitly change it with another
        <span class="code">setColor()</span> command. If you want to know what the current drawing color
        is, you can call the function <span class="code">g.getColor()</span>, which returns an object of
        type <span class="classname">Color</span>. This can be useful if you want to change to another
        drawing color temporarily and then restore the previous drawing color.</p>


    <p>Every component has an associated <span class="newword">foreground color</span> and
        <span class="newword">background color</span>. Generally, the
        component is filled with the background color before anything else is drawn
        (although some components are "transparent," meaning that the background color
        is ignored). When a new graphics context is created for a component, the
        current drawing color is set to the foreground color. Note that the foreground
        color and background color are properties of the component, not of a graphics
        context.</p>


    <p>The foreground and background colors of a component can be set by calling instance methods
        <span class="code">component.setForeground(color)</span> and <span
                class="code">component.setBackground(color)</span>, which are defined in
        the <span class="classname">Component</span> class and therefore are available for use with any
        component. This can be useful even for standard components, if you want them
        to use colors that are different from the defaults.</p>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="GUI1.3.3">6.2.3&nbsp;&nbsp;Fonts</a>
    </h3>


    <p>A <span class="newword">font</span> represents a particular size and style
        of text. The same character will appear different in different fonts. In Java,
        a font is characterized by a font name, a style, and a size. The available font
        names are system dependent, but you can always use the following four strings
        as font names: "Serif", "SansSerif", "Monospaced", and "Dialog". (A "serif" is a
        little decoration on a character, such as a short horizontal line at the bottom
        of the letter&nbsp;i. "SansSerif" means "without serifs." "Monospaced" means that
        all the characters in the font have the same width. The "Dialog" font is the
        one that is typically used in dialog boxes.)</p>


    <p>The style of a font is specified using named constants that are defined in
        the <span class="classname">Font</span> class. You can specify the style as one of the four
        values:</p>


    <ul>

        <li>
            <span class="code">Font.PLAIN</span>,
        </li>

        <li>
            <span class="code">Font.ITALIC</span>,
        </li>

        <li>
            <span class="code">Font.BOLD</span>, or
        </li>

        <li>
            <span class="code">Font.BOLD + Font.ITALIC</span>.
        </li>

    </ul>


    <p>The size of a font is an integer. Size typically ranges from about 9 to 36,
        although larger sizes can also be used. The size of a font is usually about
        equal to the height of the largest characters in the font, in pixels, but this
        is not an exact rule. The size of the default font is 12.</p>


    <p>Java uses the class named <span class="code">java.awt.Font</span> for representing fonts. You
        can construct a new font by specifying its font name, style, and size in a
        constructor:</p>


    <pre>Font plainFont = new Font("Serif", Font.PLAIN, 12);
Font bigBoldFont = new Font("SansSerif", Font.BOLD, 24);</pre>


    <p>Every graphics context has a current font, which is used for drawing text.
        You can change the current font with the <span class="code">setFont()</span> method. For
        example, if <span class="code">g</span> is a graphics context and <span class="code">bigBoldFont</span> is a
        font, then the command <span class="code">g.setFont(bigBoldFont)</span> will set the current
        font of <span class="code">g</span> to <span class="code">bigBoldFont</span>. The new font will be used
        for any text that is drawn <i>after</i> the <span class="code">setFont()</span> command is given.
        You can find out the current font
        of <span class="code">g</span> by calling the method <span class="code">g.getFont()</span>, which returns an
        object of type <span class="classname">Font</span>.</p>


    <p>Every component also has an associated font. It can be set with the instance
        method <span class="code">component.setFont(font)</span>, which is defined in the <span class="classname">Component</span>
        class. When a graphics context is created for drawing on a component, the
        graphic context's current font is set equal to the font of the component.</p>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="GUI1.3.4">6.2.4&nbsp;&nbsp;Shapes</a>
    </h3>


    <p>The <span class="classname">Graphics</span> class includes a large number of instance methods for
        drawing various shapes, such as lines, rectangles, and ovals. The shapes are
        specified using the <span class="code">(x,y)</span> coordinate system described above. They are
        drawn in the current drawing color of the graphics context. The current drawing
        color is set to the foreground color of the component when the graphics context
        is created, but it can be changed at any time using the <span class="code">setColor()</span>
        method.</p>


    <p>Some drawing methods were already listed in <a href="../c3/s9.html#control.8.1">Subsection&nbsp;3.9.1</a>.
        Here, I describe those methods in more detail and add a few more.
        With all these
        commands, any drawing that is done outside the boundaries of the component is
        ignored. Note that all these methods are in the <span class="classname">Graphics</span> class, so
        they all must be called through an object of type <span class="classname">Graphics</span>.
        It is shown here as <span class="code">g</span>, but of course
        the name of the graphics context is up to the programmer.</p>


    <ul>

        <li>
            <span class="codedef">g.drawString(String str, int x, int y)</span> -- Draws
            the text given by the string <span class="code">str</span>. The string is drawn using
            the current color and font of the graphics context. <span class="code">x</span> specifies the
            x-coordinate of the left end of the string. <span class="code">y</span> is the y-coordinate of the
            baseline of the string. The baseline is a horizontal line on which the
            characters rest. Some parts of the characters, such as the tail on a y or g,
            extend below the baseline.
        </li>


        <li>
            <span class="codedef">g.drawLine(int x1, int y1, int x2, int y2)</span> -- Draws
            a line from the point <span class="code">(x1,y1)</span> to the point
            <span class="code">(x2,y2)</span>. The line is drawn as if with a pen that extends one pixel to
            the right and one pixel down from the <span class="code">(x,y)</span> point where the pen is
            located. For example, if <span class="code">g</span> refers to an object of type
            <span class="classname">Graphics</span>, then the command <span class="code">g.drawLine(x,y,x,y)</span>,
            which
            corresponds to putting the pen down at a point, colors the single pixel with upper left corner
            at the point <span class="code">(x,y)</span>. Remember that coordinates really refer to the lines
            between the pixels.
        </li>


        <li>
            <span class="codedef">g.drawRect(int x, int y, int width, int height)</span> -- Draws
            the outline of a rectangle. The upper left corner
            is at <span class="code">(x,y)</span>, and the width and height of the rectangle are as
            specified. If <span class="code">width</span> equals <span class="code">height</span>, then the rectangle is
            a
            square. If the <span class="code">width</span> or the <span class="code">height</span> is negative, then
            nothing
            is drawn. The rectangle is drawn with the same pen that is used for
            <span class="code">drawLine()</span>. This means that the actual width of the rectangle as drawn
            is <span class="code">width+1</span>, and similarly for the height. There is an extra pixel
            along the right edge and the bottom edge. For example, if you want to draw a
            rectangle around the edges of the component, you can say "<span class="code">g.drawRect(0, 0,
getWidth()-1, getHeight()-1);</span>". If you use "<span class="code">g.drawRect(0, 0,
getWidth(), getHeight());</span>", then the right and bottom edges of the
            rectangle will be drawn <i>outside</i> the component and will not appear
            on the screen.
        </li>


        <li>
            <span class="codedef">g.drawOval(int x, int y, int width, int height)</span> -- Draws
            the outline of an oval. The oval is one that just
            fits inside the rectangle specified by <span class="code">x</span>, <span class="code">y</span>, <span
                class="code">width</span>,
            and <span class="code">height</span>. If <span class="code">width</span> equals <span
                class="code">height</span>, the oval is a
            circle.
        </li>


        <li>
<span class="codedef">g.drawRoundRect(int x, int y, int width, int height,
int xdiam, int ydiam)</span> -- Draws the outline of a rectangle with
            rounded corners. The basic rectangle is specified by <span class="code">x</span>, <span
                class="code">y</span>,
            <span class="code">width</span>, and <span class="code">height</span>, but the corners are rounded. The
            degree of
            rounding is given by <span class="code">xdiam</span> and <span class="code">ydiam</span>. The corners are
            arcs of
            an ellipse with horizontal diameter <span class="code">xdiam</span> and vertical diameter
            <span class="code">ydiam</span>. A typical value for <span class="code">xdiam</span> and <span class="code">ydiam</span>
            is 16,
            but the value used should really depend on how big the rectangle is.
        </li>


        <li>
<span class="codedef">g.draw3DRect(int x, int y, int width, int height,
boolean raised)</span> -- Draws the outline of a rectangle that is
            supposed to have a three-dimensional effect, as if it is raised from the screen
            or pushed into the screen. The basic rectangle is specified by <span class="code">x</span>,
            <span class="code">y</span>, <span class="code">width</span>, and <span class="code">height</span>. The
            <span class="code">raised</span> parameter
            tells whether the rectangle seems to be raised from the screen or pushed into
            it. The 3D effect is achieved by using brighter and darker versions of the
            drawing color for different edges of the rectangle. The documentation
            recommends setting the drawing color equal to the background color before using
            this method. The effect won't work well for some colors.
        </li>


        <li>
<span class="codedef">g.drawArc(int x, int y, int width, int height, int
startAngle, int arcAngle)</span> -- Draws part of the oval that just fits
            inside the rectangle specified by <span class="code">x</span>, <span class="code">y</span>, <span
                class="code">width</span>, and
            <span class="code">height</span>. The part drawn is an arc that extends <span class="code">arcAngle</span>
            degrees from a starting angle at <span class="code">startAngle</span> degrees. Angles are
            measured with 0 degrees at the 3 o'clock position (the positive direction of
            the horizontal axis). Positive angles are measured counterclockwise from zero,
            and negative angles are measured clockwise. To get an arc of a circle, make
            sure that <span class="code">width</span> is equal to <span class="code">height</span>.
        </li>


        <li>
<span class="codedef">g.fillRect(int x, int y, int width, int
height)</span> -- Draws a filled-in rectangle. This fills in the interior
            of the rectangle that would be drawn by <span class="code">drawRect(x,y,width,height)</span>.
            The extra pixel along the bottom and right edges is not included. The
            <span class="code">width</span> and <span class="code">height</span> parameters give the exact width and
            height
            of the rectangle. For example, if you wanted to fill in the entire component,
            you could say "<span class="code">g.fillRect(0, 0, getWidth(),
getHeight());</span>"
        </li>


        <li>
<span class="codedef">g.fillOval(int x, int y, int width, int
height)</span> -- Draws a filled-in oval.
        </li>


        <li>
<span class="codedef">g.fillRoundRect(int x, int y, int width, int height,
int xdiam, int ydiam)</span> -- Draws a filled-in rounded rectangle.
        </li>


        <li>
<span class="codedef">g.fill3DRect(int x, int y, int width, int height,
boolean raised)</span> -- Draws a filled-in three-dimensional
            rectangle.
        </li>


        <li>
<span class="codedef">g.fillArc(int x, int y, int width, int height, int
startAngle, int arcAngle)</span> -- Draw a filled-in arc. This looks like
            a wedge of pie, whose crust is the arc that would be drawn by the
            <span class="code">drawArc</span> method.
        </li>


    </ul>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="GUI1.3.5">6.2.5&nbsp;&nbsp;Graphics2D</a>
    </h3>


    <p>All drawing in Java is done through an object of type <span class="classname">Graphics</span>. The
        <span class="classname">Graphics</span> class provides basic commands for such things as drawing
        shapes and text and for selecting a drawing color. These commands are adequate in many cases, but
        they fall far short of what's needed in a serious computer graphics program.
        Java has another class, <span class="classname">Graphics2D</span>, that provides a larger
        set of drawing operations. <span class="classname">Graphics2D</span> is a sub-class of
        <span class="classname">Graphics</span>, so all the methods from the <span class="classname">Graphics</span>
        class are
        also available in a <span class="classname">Graphics2D</span>.</p>


    <p>The <span class="code">paintComponent()</span> method of a <span class="code">JComponent</span> gives you a
        graphics context of type <span class="classname">Graphics</span> that you can use for drawing on the
        component. In fact, the graphics context actually belongs to the sub-class
        <span class="classname">Graphics2D</span>, and can be type-cast to
        gain access to the advanced <span class="classname">Graphics2D</span> drawing methods:</p>


    <pre>public void paintComponent(Graphics g) {
   super.paintComponent(g);
   Graphics2D g2;
   g2 = (Graphics2D)g;
    .
    . // Draw on the component using g2.
    .
}</pre>


    <p>I mention <span class="classname">Graphics2D</span> here for completeness.
        I will cover some important aspects of <span class="classname">Graphics2D</span>
        in <a href="../c13/s2.html">Section&nbsp;13.2</a>, but a full treatment is more than we will have
        time for in this book. However, there are two simple applications
        that I would like to start using now, without explaining how they work.
        If <span class="code">g2</span> is a variable of type <span class="classname">Graphics2D</span>,
        as in the <span class="code">paintComponent()</span> method above, then the
        intimidating-looking command</p>


    <pre>g2.setRenderingHint( RenderingHints.KEY_ANTIALIASING,
                                RenderingHints.VALUE_ANTIALIAS_ON );</pre>


    <p>turns on antialiasing in the graphics context. Aliasing is a jagged appearance
        that can be seen when shapes are drawn using pixels. Antialiasing tries to reduce
        the jaggedness. It can make diagonal lines and the outlines of ovals look much nicer.
        It can also improve the appearance of text. Another useful command is</p>


    <pre>g2.setStroke( new BasicStroke(lineWidth) );</pre>


    <p>where <span class="code">lineWidth</span> is an integer or a float. This command can be used to
        draw thicker lines. Lines drawn after the command will be <span class="code">lineWidth</span> pixels
        wide. This also affects the thickness of the outlined shapes drawn by methods such as
        <span class="code">g.drawRect</span> and <span class="code">g.drawOval()</span>.</p>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="GUI1.3.6">6.2.6&nbsp;&nbsp;An Example</a>
    </h3>


    <p>Let's use some of the material covered in this section to write a subclass
        of <span class="classname">JPanel</span> for use as a drawing surface.
        All the drawing will be done in the
        <span class="code">paintComponent()</span> method of the panel class.
        The panel will draw multiple copies of a message on a black background.
        Each copy of the message is in a random color. Five different fonts are used,
        with different sizes and styles. The message can be specified in the constructor;
        if the default constructor is used, the message is the string "Java!". The
        panel works OK no matter what its size.</p>


    <p>There is one problem with the way this class works. When the panel's
        <span class="code">paintComponent()</span> method is called, it chooses random colors, fonts,
        and locations for the messages. The information about which colors, fonts, and
        locations are used is not stored anywhere. The next time
        <span class="code">paintComponent()</span> is called, it will make different random choices and
        will draw a different picture. If you resize a window containing the panel,
        the picture will be continually redrawn as the size of the window is changed!
        To avoid that, you would store enough information about the picture in instance variables
        to enable the <span class="code">paintComponent()</span> method to draw the same picture each
        time it is called.</p>


    <p>The source code for the panel class is shown below. I use an instance variable called
        <span class="code">message</span> to hold the message that the panel will display. There are
        five instance variables of type <span class="classname">Font</span> that represent different sizes
        and styles of text. These variables are initialized in the constructor
        and are used in the <span class="code">paintComponent()</span> method.</p>


    <p>The <span class="code">paintComponent()</span> method for the panel simply draws 25
        copies of the message. For each copy, it chooses one of the five fonts at
        random, and it uses <span class="code">g.setFont()</span> to select that font for drawing.
        It creates a random HSB color and uses <span class="code">g.setColor()</span> to select
        that color for drawing. It then chooses random <span class="code">(x,y)</span> coordinates for
        the location of the message. The <span class="code">x</span> coordinate gives the horizontal
        position of the left end of the string. The formula used for the <span class="code">x</span>
        coordinate is "<span class="code">-50&nbsp;+ (int)(Math.random() * (width+40))</span>". This gives a random
        integer in the range from <span class="code">-50</span> to <span class="code">width-10</span>. This makes it
        possible for the string to extend beyond the left edge or the right edge of the
        panel. Similarly, the formula for <span class="code">y</span> allows the string to extend
        beyond the top and bottom.</p>


    <p>Here is the complete source code for the <span class="classname">RandomStringsPanel</span>:</p>


    <pre>import java.awt.*;
import javax.swing.JPanel;

/**
 * This panel displays 25 copies of a message.  The color and 
 * position of each message is selected at random.  The font
 * of each message is randomly chosen from among five possible
 * fonts.  The messages are displayed on a black background.
 * Note:  The style of drawing used here is poor, because every
 * time the paintComponent() method is called, new random values are
 * used.  This means that a different picture will be drawn each time.  
 */
public class RandomStringsPanel extends JPanel {

    private String message;  // The message to be displayed.  This can be set in
                             // the constructor.  If no value is provided in the
                             // constructor, then the string "Java!" is used.

    private Font font1, font2, font3, font4, font5;  // The five fonts.

    /**
     * Default constructor creates a panel that displays the message "Java!".
     */
    public RandomStringsPanel() {
        this(null);  // Call the other constructor, with parameter null.
    }

    /**
     * Constructor creates a panel to display 25 copies of a specified message.
     * @param messageString The message to be displayed.  If this is null,
     * then the default message "Java!" is displayed.
     */
    public RandomStringsPanel(String messageString) {

        message = messageString;
        if (message == null)
            message = "Java!";

        font1 = new Font("Serif", Font.BOLD, 14);
        font2 = new Font("SansSerif", Font.BOLD + Font.ITALIC, 24);
        font3 = new Font("Monospaced", Font.PLAIN, 30);
        font4 = new Font("Dialog", Font.PLAIN, 36);
        font5 = new Font("Serif", Font.ITALIC, 48);

        setBackground(Color.BLACK);

    }

    /**
     * The paintComponent method is responsible for drawing the content of the panel.
     * It draws 25 copies of the message string, using a random color, font, and
     * position for each string.
     */
    public void paintComponent(Graphics g) {

        super.paintComponent(g);  // Call the paintComponent method from the 
                                  // superclass, JPanel.  This simply fills the 
                                  // entire panel with the background color, black.
        
        Graphics2D g2 = (Graphics2D)g;  // (To make the text smoother.)
        g2.setRenderingHint( RenderingHints.KEY_ANTIALIASING, 
                                RenderingHints.VALUE_ANTIALIAS_ON );

        int width = getWidth();
        int height = getHeight();

        for (int i = 0; i &lt; 25; i++) {

            // Draw one string.  First, set the font to be one of the five
            // available fonts, at random.  

            int fontNum = (int)(5*Math.random()) + 1;
            switch (fontNum) {
            case 1:
                g.setFont(font1);
                break;
            case 2:
                g.setFont(font2);
                break;
            case 3:
                g.setFont(font3);
                break;
            case 4:
                g.setFont(font4);
                break;
            case 5:
                g.setFont(font5);
                break;
            } // end switch

            // Set the color to a bright, saturated color, with random hue.

            float hue = (float)Math.random();
            g.setColor( Color.getHSBColor(hue, 1.0F, 1.0F) );

            // Select the position of the string, at random.

            int x,y;
            x = -50 + (int)(Math.random()*(width+40));
            y = (int)(Math.random()*(height+20));

            // Draw the message.

            g.drawString(message,x,y);

        } // end for

    } // end paintComponent()


}  // end class RandomStringsPanel
</pre>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="GUI1.3.7">6.2.7&nbsp;&nbsp;Where is main()?</a>
    </h3>


    <p>The source code for the <span class="classname">RandomStringsPanel</span> class can be
        found in the example file <span class="sourceref"><a href="../source/chapter6/RandomStringsPanel.java">RandomStringsPanel.java</a></span>.
        You can
        compile that file, but you won't be able to run the compiled class. The problem is
        that the class doesn't have a <span class="code">main()</span> routine. Only a class that has a
        <span class="code">main()</span> routine can be run as a program.</p>


    <p>Another problem is that a <span class="classname">JPanel</span> is not something that
        can stand on its own. It has to be placed into a container such as another
        panel or a window. In general, to make a complete program, we need a <span class="code">main()</span>
        routine that will create a window of type <span class="classname">JFrame</span>. It can then
        create a panel and place the panel in the window. Here is a class with a
        <span class="code">main()</span> routine that does this:</p>


    <pre>
import javax.swing.JFrame;

public class RandomStrings {
    
    public static void main(String[] args) {
        JFrame window = new JFrame("Java!");
        RandomStringsPanel content = new RandomStringsPanel();
        window.setContentPane(content);
        window.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        window.setLocation(120,70);
        window.setSize(350,250);
        window.setVisible(true);
    }

}</pre>


    <p>This class is defined by the file <span class="sourceref"><a href="../source/chapter6/RandomStrings.java">RandomStrings.java</a></span>.
        You can compile
        and run the program, as long as the <span class="classname">RandomStringsPanel</span> class is also
        available.</p>


    <p>The main routine is not logically a part of the panel class. It is just one way
        of using a panel. However, it's possible to include <span class="code">main()</span> as part of the
        panel class, even if it doesn't logically belong there. This makes it possible to run
        the panel class as a program, and it has the advantage of keeping everything in one
        file. For an example, you can look at
        <span class="sourceref"><a href="../source/chapter6/RandomStringsPanelWithMain.java">RandomStringsPanelWithMain.java</a></span>,
        which is identical to
        the original class except for the addition of a <span class="code">main()</span> routine.
        Although it might not be great style, I will usually take a similar approach
        in future examples.</p>


    <p>I am not going to discuss the
        details of using <span class="classname">JFrame</span> here, but you can look ahead
        and find them in <a href="../c6/s7.html#GUI1.8.3">Subsection&nbsp;6.7.3</a>. You won't completely understand
        my <span class="code">main()</span> routines until you read that section.</p>


</div>
<hr>
<div align="right">
    <small>
        [ <a href="s1.html">Previous Section</a> |
        <a href="s3.html">Next Section</a> |
        <a href="index.html">Chapter Index</a> |
        <a href="../index.html">Main Index</a> ]
    </small>
</div>
</body>
</html>
