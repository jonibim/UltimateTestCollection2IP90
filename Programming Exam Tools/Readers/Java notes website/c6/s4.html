<html>
<head>
    <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Javanotes 7.0, Section 6.4 -- Timers, KeyEvents, and State Machines</title>
    <link type="text/css" rel="stylesheet" href="../javanotes.css">
</head>
<body>
<div align="right">
    <small>
        [ <a href="s3.html">Previous Section</a> |
        <a href="s5.html">Next Section</a> |
        <a href="index.html">Chapter Index</a> |
        <a href="../index.html">Main Index</a> ]
    </small>
</div>
<hr>
<table class="subsections" vspace="8" hspace="8" cellpadding="5" border="2" align="right">
    <tr>
        <td>
            <div align="center">
                <b>Subsections</b>
                <hr>
                <small><a href="#GUI1.5.1">Timers and Animation</a>
                    <br>
                    <a href="#GUI1.5.2">Keyboard Events</a>
                    <br>
                    <a href="#GUI1.5.3">Focus Events</a>
                    <br>
                    <a href="#GUI1.5.4">State Machines</a>
                    <br>
                </small>
            </div>
        </td>
    </tr>
</table>
<div class="content">
    <h3 class="section_title">Section 6.4</h3>
    <h2 class="section_title">Timers, KeyEvents, and State Machines</h2>
    <hr class="break">


    <p>
        <span class="start"><big>N</big>ot every event</span> is generated by an action on the
        part of the user. Events can also be generated by objects as part of their
        regular programming, and these events can be monitored by other objects so that
        they can take appropriate actions when the events occur. One example of this
        is the class <span class="code">javax.swing.Timer</span>. A <span class="classname">Timer</span>
        generates events at regular intervals. These events can be used to drive
        an animation or to perform some other task at regular intervals. We will
        begin this section with a look at timer events and animation. We will then
        look at another type of basic user-generated event: the <span class="classname">KeyEvents</span>
        that are generated when the user types on the keyboard. The example at the end
        of the section uses both a timer and keyboard events to implement a simple game
        and introduces the important idea of <span class="newword">state machines</span>.</p>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="GUI1.5.1">6.4.1&nbsp;&nbsp;Timers and Animation</a>
    </h3>


    <p>An object belonging to the class <span class="code">javax.swing.Timer</span> exists only to
        generate events. A <span class="classname">Timer</span>, by default, generates a sequence of events
        with a fixed delay between each event and the next. (It is also possible to set a
        <span class="classname">Timer</span> to emit a single event after a specified time delay;
        in that case, the timer is being used as an "alarm.") Each event belongs to the
        class <span class="classname">ActionEvent</span>. An object that is to listen for the
        events must implement the interface <span class="classname">ActionListener</span>, which
        defines just one method:</p>


    <pre>public void actionPerformed(ActionEvent evt)</pre>


    <p>To use a <span class="classname">Timer</span>, you must create an object that
        implements the <span class="classname">ActionListener</span> interface. That is, the
        object must belong to a class that is declared to "<span class="code">implement ActionListener</span>",
        and that class must define the <span class="code">actionPerformed</span> method. Then, if
        the object is set to listen for events from the timer, the code in the listener's
        <span class="code">actionPerformed</span> method will be executed every time the timer generates
        an event.</p>


    <p>Since there is no point to having a timer without having a listener to respond to
        its events, the action listener for a timer is specified as a parameter in the
        timer's constructor. The time delay between timer events is also specified in
        the constructor. If <span class="code">timer</span> is a variable of type <span class="classname">Timer</span>,
        then the statement</p>


    <pre>timer = new Timer( millisDelay, listener );</pre>


    <p>creates a timer with a delay of <span class="code">millisDelay</span> milliseconds
        between events (where 1000 milliseconds equal one second). Events from the
        timer are sent to the <span class="code">listener</span>. (<span class="code">millisDelay</span> must be
        of type <span class="ptype">int</span>, and <span class="code">listener</span> must be of type
        <span class="classname">ActionListener</span>.) The listener's <span class="code">actionPerfomed()</span>
        will be executed every time the timer emits an event.
        Note that a timer is not guaranteed
        to deliver events at precisely regular intervals. If the computer is busy
        with some other task, an event might be delayed or even dropped altogether.</p>


    <p>A timer does not automatically start generating events when the timer object
        is created. The <span class="code">start()</span> method in the timer must be called to tell
        the timer to start running. The timer's <span class="code">stop()</span> method
        can be used to turn the stream of events off. It can be restarted later by calling
        <span class="code">start()</span> again.</p>


    <hr class="break">


    <p>One application of timers is computer animation.
        A computer animation is just a sequence of still images, presented to the user
        one after the other. If the time between images is short, and if the change from one
        image to another is not too great, then the user perceives continuous motion.
        The easiest way to do animation in Java is to use a <span class="classname">Timer</span> to
        drive the animation. Each time the timer generates an event, the next frame of
        the animation is computed and drawn on the screen -- the code that implements this goes
        in the <span class="code">actionPerformed</span> method of an object that listens for events from
        the timer.</p>


    <p>Our first example of using a timer is not exactly an animation, but it does
        display a new image for each timer event. The program shows randomly generated
        images that vaguely resemble works of abstract art. In fact, the program
        draws a new random image every time its <span class="code">paintComponent()</span> method is
        called, and the response to a timer event is simply to call <span class="code">repaint()</span>,
        which in turn triggers a call to <span class="code">paintComponent</span>. The work
        of the program is done in a subclass of <span class="classname">JPanel</span>, which
        starts like this:</p>


    <pre>import java.awt.*;
import java.awt.event.*;
import javax.swing.*;

public class RandomArtPanel extends JPanel {
   
   /**
    * A RepaintAction object calls the repaint method of this panel each
    * time its actionPerformed() method is called.  An object of this
    * type is used as an action listener for a Timer that generates an
    * ActionEvent every four seconds.  The result is that the panel is
    * redrawn every four seconds.
    */
   private class RepaintAction implements ActionListener {
      public void actionPerformed(ActionEvent evt) {
         repaint();  // Call the repaint() method in the panel class.
      }
   }
   
   /**
    * The constructor creates a timer with a delay time of four seconds
    * (4000 milliseconds), and with a RepaintAction object as its
    * ActionListener.  It also starts the timer running.
    */
   public RandomArtPanel() {
      RepaintAction action = new RepaintAction();
      Timer timer = new Timer(4000, action);
      timer.start();
   }
   
   /**
    * The paintComponent() method fills the panel with a random shade of
    * gray and then draws one of three types of random "art".  The type
    * of art to be drawn is chosen at random.
    */
   public void paintComponent(Graphics g) {
       .
       .   // The rest of the class is omitted
       .</pre>


    <p>You can find the full source code for this class in the file <span class="sourceref"><a
            href="../source/chapter6/RandomArt.java">RandomArt.java</a></span>.
        I will only note that the very short <span class="classname">RepaintAction</span> class is a natural
        candidate to be replaced by an anonymous inner class. That can be done where the timer is
        created:
    </p>


    <pre>Timer timer = new timer(4000, new ActionListener() {
        public void actionPerformed(ActionEvent evt) {
            repaint();
        }
    });
</pre>


    <p>Later in this section, we will use a timer to drive the animation in a simple
        computer game.</p>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="GUI1.5.2">6.4.2&nbsp;&nbsp;Keyboard Events</a>
    </h3>


    <p>In Java, user actions become events in a program. These events
        are associated with GUI components.
        When the user presses a button on the mouse, the event that is generated is
        associated with the component that contains the mouse cursor. What about
        keyboard events? When the user presses a key, what component is associated with
        the key event that is generated?</p>


    <p>A GUI uses the idea of <span class="newword">input focus</span> to determine
        the component associated with keyboard events. At any given time, exactly one
        interface element on the screen has the input focus, and that is where all
        keyboard events are directed. If the interface element happens to be a Java
        component, then the information about the keyboard event becomes a Java object
        of type <span class="classname">KeyEvent</span>, and it is delivered to any listener objects that are
        listening for <span class="code">KeyEvents</span> associated with that component. The necessity
        of managing input focus adds an extra twist to working with keyboard events.</p>


    <p>It's a good idea to give the user some visual feedback about which component
        has the input focus. For example, if the component is the typing area of a
        word-processor, the feedback is usually in the form of a blinking text cursor.
        Another possible visual clue is to draw a brightly colored border around the edge
        of a component when it has the input focus, as I do in the examples given
        later in this section.</p>


    <p>If <span class="code">comp</span> is any component, and you would like it to have the
        input focus, you can call <span class="code">requestFocusInWindow()</span>, which should
        work as long as the window that contains the component is active and there
        is only one component that is requesting focus. In some cases,
        when there is only one component involved, it is enough to call this method
        once, just after opening the window, and the component will retain the focus
        for the rest of the program. (Note that there is also a <span class="code">requestFocus()</span>
        method that might work even when the window is not active,
        but the newer method <span class="code">requestFocusInWindow()</span> is preferred in
        most cases.)</p>


    <p>In a typical user interface, the user can choose to give the focus to a component by
        clicking on that component with the mouse. And pressing the tab key will often
        move the focus from one component to another. This is handled automatically by
        the components involved, without any programming on your part.
        However, some components do not automatically request the input focus when the user
        clicks on them. To solve this problem, a program can register a mouse
        listener with the component to detect user clicks. In response to a user click,
        the <span class="code">mousePressed()</span> method should call <span class="code">requestFocusInWindow()</span>
        for the
        component. This is true, in particular, for <span class="classname">JPanels</span> that are used as
        drawing surfaces, since <span class="classname">JPanel</span> objects do not receive the input
        focus automatically.</p>


    <p>As our first example of processing key events, we look at a simple program in
        which the user moves a square up, down, left, and right by pressing arrow keys.
        When the user hits the 'R', 'G', 'B', or 'K' key, the color of the square is set to
        red, green, blue, or black, respectively. Of course, none of these key events
        are delivered to the panel unless it has the input focus. The panel in the
        program changes its appearance when it has the input focus: When it does,
        a cyan-colored border is drawn around the panel; when it does not, a gray-colored
        border is drawn. The complete source code for this example
        can be found in the file <span class="sourceref"><a href="../source/chapter6/KeyboardAndFocusDemo.java">KeyboardAndFocusDemo.java</a></span>.
        I will discuss some aspects of it below. After reading this section, you should be
        able to understand the source code in its entirety. I suggest running the program to
        see how it works.</p>


    <p>In Java, keyboard event objects belong to a class called <span class="classname">KeyEvent</span>.
        An object that needs to listen for <span class="classname">KeyEvents</span> must implement the
        interface named <span class="classname">KeyListener</span>. Furthermore, the object must be
        registered with a component by calling the component's
        <span class="code">addKeyListener()</span> method. The registration is done with the command
        "<span class="code">component.addKeyListener(listener);</span>" where <span class="code">listener</span> is the
        object that is to listen for key events, and <span class="code">component</span> is the object
        that will generate the key events (when it has the input focus). It is possible
        for <span class="code">component</span> and <span class="code">listener</span> to be the same object. All this
        is, of course, directly analogous to what you learned about mouse events in the
        <a href="../c6/s3.html">previous section</a>. The <span class="classname">KeyListener</span> interface
        defines the following methods, which must be included in any class that
        implements <span class="classname">KeyListener</span>:</p>


    <pre>public void keyPressed(KeyEvent evt);
public void keyReleased(KeyEvent evt);
public void keyTyped(KeyEvent evt);</pre>


    <p>Java makes a careful distinction between <i>the keys that you press</i> and
        <i>the characters that you type</i>. There are lots of keys on a keyboard:
        letter keys, number keys, modifier keys such as Control and Shift, arrow keys,
        page up and page down keys, keypad keys, function keys, and so on. In some cases, such as the shift key,
        pressing a key does not type a character. On the other hand, typing a character
        sometimes involves pressing several keys. For example, to type an uppercase
        'A', you have to press the Shift key and then press the A key before releasing
        the Shift key. On my Mac&nbsp;OS computer, I can type an accented e, by
        holding down the Option key, pressing the E key, releasing the Option key, and
        pressing E again. Only one character was typed, but I had to perform three
        key-presses and I had to release a key at the right time. In Java, there are
        three types of <span class="classname">KeyEvent</span>. The types correspond to pressing a key,
        releasing a key, and typing a character. The <span class="code">keyPressed</span> method is
        called when the user presses a key, the <span class="code">keyReleased</span> method is called
        when the user releases a key, and the <span class="code">keyTyped</span> method is called when
        the user types a character (whether that's done with one key press or several).
        Note that one user action, such as pressing the E
        key, can be responsible for two events, a <span class="code">keyPressed</span> event and a
        <span class="code">keyTyped</span> event. Typing an upper case 'A' can generate two
        <span class="code">keyPressed</span> events, two <span class="code">keyReleased</span> events, and one <span
                class="code">keyTyped</span>
        event.</p>


    <p>Usually, it is better to think in terms of two separate streams of events,
        one consisting of <span class="code">keyPressed</span> and <span class="code">keyReleased</span> events and the
        other consisting of <span class="code">keyTyped</span> events. For some applications, you want
        to monitor the first stream; for other applications, you want to monitor the
        second one. Of course, the information in the <span class="code">keyTyped</span> stream could be
        extracted from the <span class="code">keyPressed/keyReleased</span> stream, but it would be
        difficult (and also system-dependent to some extent). Some user actions, such
        as pressing the Shift key, can only be detected as <span class="code">keyPressed</span> events.
        I used to have a computer solitaire game that highlighted every card that could be
        moved, when I held down the Shift key. You can do something like that in Java
        by highlighting the cards when the Shift key is pressed and removing the highlight
        when the Shift key is released.</p>


    <p>There is one more complication. Usually, when you hold down a key on the
        keyboard, that key will <span class="newword">auto-repeat</span>. This means
        that it will generate multiple <span class="code">keyPressed</span> events with just one
        <span class="code">keyReleased</span> at the end of the sequence.
        It can also generate multiple <span class="code">keyTyped</span> events. For the most
        part, this will not affect your programming, but you should not expect every
        <span class="code">keyPressed</span> event to have a corresponding <span class="code">keyReleased</span>
        event.</p>


    <p>Every key on the keyboard has an integer code number. (Actually, this is
        only true for keys that Java knows about. Many keyboards have extra keys that
        can't be used with Java.) When the <span class="code">keyPressed</span> or <span class="code">keyReleased</span>
        method is called, the parameter, <span class="code">evt</span>, contains the code of the key
        that was pressed or released. The code can be obtained by calling the function
        <span class="code">evt.getKeyCode()</span>. Rather than asking you to memorize a table of code
        numbers, Java
        provides a named constant for each key. These constants are defined in the
        <span class="classname">KeyEvent</span> class. For example the constant for the shift key is
        <span class="code">KeyEvent.VK_SHIFT</span>. If you want to test whether the key that the user
        pressed is the Shift key, you could say "<span class="code">if (evt.getKeyCode() ==
KeyEvent.VK_SHIFT)</span>". The key codes for the four arrow keys are
        <span class="code">KeyEvent.VK_LEFT</span>, <span class="code">KeyEvent.VK_RIGHT</span>, <span class="code">KeyEvent.VK_UP</span>,
        and <span class="code">KeyEvent.VK_DOWN</span>. Other keys have similar codes. (The "VK" stands
        for "Virtual Keyboard". In reality, different keyboards use different key
        codes, but Java translates the actual codes from the keyboard into its own
        "virtual" codes. Your program only sees these virtual key codes, so it will
        work with various keyboards on various platforms without modification.)</p>


    <p>In the case of a <span class="code">keyTyped</span> event, you want to know which character
        was typed. This information can be obtained from the parameter, <span class="code">evt</span>,
        in the <span class="code">keyTyped</span> method by calling the function
        <span class="code">evt.getKeyChar()</span>. This function returns a value of type <span
                class="ptype">char</span>
        representing the character that was typed.</p>


    <p>In the <span class="code">KeyboardAndFocusDemo</span> program, I use the
        <span class="code">keyPressed</span> routine to respond when the user presses one of the arrow
        keys. The program includes instance variables, <span class="code">squareLeft</span> and
        <span class="code">squareTop</span>, that give the position of the upper left corner of the movable
        square. When the user presses one of the arrow keys, the <span class="code">keyPressed</span>
        routine modifies the appropriate instance variable and calls
        <span class="code">repaint()</span> to redraw the panel with the square in its new position. Note that the
        values of <span class="code">squareLeft</span> and <span class="code">squareTop</span> are restricted so that
        the square never moves outside the white area of the panel:</p>


    <pre>/**
 * This is called each time the user presses a key while the panel has
 * the input focus.  If the key pressed was one of the arrow keys,
 * the square is moved (except that it is not allowed to move off the
 * edge of the panel, allowing for a 3-pixel border).
 */
public void keyPressed(KeyEvent evt) { 
   
   int key = evt.getKeyCode();  // keyboard code for the pressed key
   
   if (key == KeyEvent.VK_LEFT) {  // left-arrow key; move the square left
      squareLeft -= 8;
      if (squareLeft &lt; 3)
         squareLeft = 3;
      repaint();
   }
   else if (key == KeyEvent.VK_RIGHT) {  // right-arrow key; move the square right
      squareLeft += 8;
      if (squareLeft &gt; getWidth() - 3 - SQUARE_SIZE)
         squareLeft = getWidth() - 3 - SQUARE_SIZE;
      repaint();
   }
   else if (key == KeyEvent.VK_UP) {  // up-arrow key; move the square up
      squareTop -= 8;
      if (squareTop &lt; 3)
         squareTop = 3;
      repaint();
   }
   else if (key == KeyEvent.VK_DOWN) {  // down-arrow key; move the square down
      squareTop += 8;
      if (squareTop &gt; getHeight() - 3 - SQUARE_SIZE)
         squareTop = getHeight() - 3 - SQUARE_SIZE;
      repaint();
   }
   
}  // end keyPressed()</pre>


    <p>Color changes -- which happen when the user types the characters 'R', 'G',
        'B', and 'K', or the lower case equivalents -- are handled in the
        <span class="code">keyTyped</span> method. I won't include it here, since it is so similar to
        the <span class="code">keyPressed</span> method. Finally, to complete the <span
                class="classname">KeyListener</span>
        interface, the <span class="code">keyReleased</span> method must be defined. In the sample
        program, the body of this method is empty since the program does nothing in
        response to <span class="code">keyReleased</span> events.</p>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="GUI1.5.3">6.4.3&nbsp;&nbsp;Focus Events</a>
    </h3>


    <p>If a component is to change its appearance when it has the input focus, it
        needs some way to know when it has the focus. In Java, objects are notified
        about changes of input focus by events of type <span class="classname">FocusEvent</span>. An object
        that wants to be notified of changes in focus can implement the
        <span class="classname">FocusListener</span> interface. This interface declares two methods:</p>


    <pre>public void focusGained(FocusEvent evt);
public void focusLost(FocusEvent evt);</pre>


    <p>Furthermore, the <span class="code">addFocusListener()</span> method must be used to set up a
        listener for the focus events. When a component gets the input focus, it calls
        the <span class="code">focusGained()</span> method of any registered with
        <span class="classname">FocusListener</span>. When it loses the focus, it calls
        the listener's <span class="code">focusLost()</span> method.</p>


    <p>In the sample <span class="code">KeyboardAndFocusDemo</span> program, the response to
        a focus event is simply to redraw the panel. The <span class="code">paintComponent()</span>
        method checks whether the panel has the input focus by calling the
        <span class="ptype">boolean</span>-valued function <span class="code">hasFocus()</span>, which is
        defined in the <span class="classname">Component</span> class, and it draws a
        different picture depending on whether or not the panel has the input focus.
        The net result is that the appearance of the panel changes when the panel
        gains or loses focus. The methods from the <span class="classname">FocusListener</span>
        interface are defined simply as:</p>


    <pre>public void focusGained(FocusEvent evt) {
       // The panel now has the input focus.
   repaint();  // will redraw with a new message and a cyan border
}
 
public void focusLost(FocusEvent evt) {
      // The panel has now lost the input focus.
   repaint();  // will redraw with a new message and a gray border
}</pre>


    <p>The other aspect of handling focus is to make sure that the panel
        actually gets the focus. In this case, I called <span class="code">requestFocusInWindow()</span>
        for the panel in the program's <span class="code">main()</span> routine, just after
        opening the window. This approach works because there is only one component
        in the window, and it should have focus as long as the window is active.
        If the user clicks over to another window while using the program, the
        window becomes inactive and the panel loses focus temporarily, but gets
        is back when the user clicks back to the program window.</p>


    <p>There are still decisions to be made about the overall structure of
        the program. In this case, I decided to use a nested class named <span class="classname">Listener</span> to
        define
        an object that listens for both focus and key events. In the constructor for the panel, I create
        an object of type <span class="classname">Listener</span> and register it to listen for both
        key events and focus events from the panel. See the <span class="sourceref"><a
                href="../source/chapter6/KeyboardAndFocusDemo.java">source code</a></span>
        for full details.</p>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="GUI1.5.4">6.4.4&nbsp;&nbsp;State Machines</a>
    </h3>


    <p>The information stored in an object's instance variables is said to
        represent the <span class="newword">state</span> of that object. When one of
        the object's methods is called, the action taken by the object can depend on
        its state. (Or, in the terminology we have been using, the definition of the
        method can look at the instance variables to decide what to do.) Furthermore,
        the state can change. (That is, the definition of the method can assign new
        values to the instance variables.) In computer science, there is the idea of a
        <span class="newword">state machine</span>, which is just something that has a
        state and can change state in response to events or inputs. The response of a
        state machine to an event depends on what state it's in when the event occurs. An object is
        a kind of state machine. Sometimes, this point of view can be very useful in
        designing classes.</p>


    <p>The state machine point of view can be especially useful in the type of
        event-oriented programming that is required by graphical user interfaces. When
        designing a GUI program, you can ask yourself: What information about state do I
        need to keep track of? What events can change the state of the program? How will
        my response to a given event depend on the current state? Should the appearance
        of the GUI be changed to reflect a change in state? How should the
        <span class="code">paintComponent()</span> method take the state into account? All this is an
        alternative to the top-down, step-wise-refinement style of program design,
        which does not apply to the overall design of an event-oriented program.</p>


    <p>In the <span class="classname">KeyboardAndFocusDemo</span> program, shown above, the state of the
        program is recorded in the instance variables <span class="code">squareColor</span>,
        <span class="code">squareLeft</span>, and <span class="code">squareTop</span>. These state variables are used in
        the <span class="code">paintComponent()</span> method to decide how to draw the panel. Their values are
        changed in the two key-event-handling methods.</p>


    <p>In the rest of this section, we'll look at another example, where the state
        plays an even bigger role. In this example, the user plays a
        simple arcade-style game by pressing the arrow keys. The
        program is defined in the source code file <span class="sourceref"><a href="../source/chapter6/SubKiller.java">SubKiller.java</a></span>.
        As usual, it would be a good idea to compile and run the program as well
        as read the full source code. Here is a picture:</p>


    <p align="center">
        <img src="sub-killer.png" width="398" height="275"
             alt="the SubKiller window, showing a 'boat' and a 'submarine'"></p>


    <p>The program shows a black "submarine" near the bottom of the panel.
        While the panel has the input focus, this submarine
        moves back and forth erratically near the bottom. Near the top,
        there is a blue "boat." You can move this boat back and forth by pressing the
        left and right arrow keys. Attached to the boat is a red "bomb" (or "depth charge"). You
        can drop the bomb by hitting the down arrow key. The objective is to
        blow up the submarine by hitting it with the bomb. If the bomb
        falls off the bottom of the screen, you get a new one. If the submarine explodes, a
        new sub is created and you get a new bomb. Try it! Make sure to hit the
        sub at least once, so you can see the explosion.</p>


    <p>Let's think about how this game can be programmed. First of all, since we
        are doing object-oriented programming, I decided to represent the boat, the depth
        charge, and the submarine as objects. Each of these objects is defined by a
        separate nested class inside the main panel class, and each object has its own
        state which is represented by the instance variables in the corresponding class.
        I use variables <span class="code">boat</span>, <span class="code">bomb</span>, and <span
                class="code">sub</span> in
        the panel class to refer to the boat, bomb, and submarine objects.</p>


    <p>Now, what constitutes the
        "state" of the program? That is, what things change from time to time and affect
        the appearance or behavior of the program? Of course, the state includes the
        positions of the boat, submarine, and bomb, so those objects have instance
        variables to store the positions. Anything else, possibly less obvious? Well,
        sometimes the bomb is falling, and sometimes it's not. That is a
        difference in state. Since there are two possibilities, I represent this aspect
        of the state with a boolean variable in the <span class="code">bomb</span> object,
        <span class="code">bomb.isFalling</span>. Sometimes the
        submarine is moving left and sometimes it is moving right. The difference is
        represented by another boolean variable, <span class="code">sub.isMovingLeft</span>. Sometimes,
        the sub is exploding. This is also part of the state, and it is represented
        by a boolean variable, <span class="code">sub.isExploding</span>. However, the explosions
        require a little more thought. An explosion is something that takes place
        over a series of frames. While an explosion is in progress, the sub
        looks different in each frame, as the size of the explosion increases. Also,
        I need to know when the explosion is over so that I can go back to moving and drawing the
        sub as usual. So, I use an integer variable, <span class="code">sub.explosionFrameNumber</span>
        to record how many frames have been drawn since the explosion
        started; the value of this variable is used only when an explosion is in progress.</p>


    <p>How and when do the values of these state variables change? Some of them seem
        to change on their own: For example, as the sub moves left and right, the state variables
        that specify its position change. Of course, these variables are changing
        because of an animation, and that animation is driven by a timer. Each time an
        event is generated by the timer, some of the state variables have to change to
        get ready for the next frame of the animation. The changes are made by the
        action listener that listens for events from the timer. The <span class="code">boat</span>,
        <span class="code">bomb</span>, and <span class="code">sub</span> objects each contain an
        <span class="code">updateForNextFrame()</span> method that updates the state variables of
        the object to get ready for the next frame of the animation. The action listener
        for the timer calls these methods with the statements</p>


    <pre>boat.updateForNewFrame();
bomb.updateForNewFrame();
sub.updateForNewFrame();</pre>


    <p>The action listener also calls <span class="code">repaint()</span>, so that the panel will be
        redrawn to reflect its new state. There are several state variables that change
        in these update methods, in addition to the position of the sub: If the bomb is
        falling, then its y-coordinate increases from one frame to the next. If the
        bomb hits the sub, then the <span class="code">isExploding</span> variable of the sub
        changes to true, and the <span class="code">isFalling</span> variable of the bomb becomes <span class="code">false</span>.
        The <span class="code">isFalling</span> variable also becomes false when the bomb falls off the
        bottom of the screen. If the sub is exploding, then its <span class="code">explosionFrameNumber</span>
        increases from one frame to the next, and when it reaches a certain value, the
        explosion ends and <span class="code">isExploding</span> is reset to false. At random times,
        the sub switches between moving to the left and moving to the right. Its
        direction of motion is recorded in the sub's <span class="code">isMovingLeft</span> variable.
        The sub's <span class="code">updateForNewFrame()</span> method includes these lines to
        change the value of <span class="code">isMovingLeft</span> at random times:</p>


    <pre>if ( Math.random() &lt; 0.04 )
   isMovingLeft = ! isMovingLeft;</pre>


    <p>There is a 1 in 25 chance that <span class="code">Math.random()</span> will be less than
        0.04, so the statement "<span class="code">isMovingLeft = !&nbsp;isMovingLeft</span>" is executed
        in one in every twenty-five frames, on average. The effect of this statement
        is to reverse the value of <span class="code">isMovingLeft</span>, from false to true or from
        true to false. That is, the direction of motion of the sub is reversed.</p>


    <p>In addition to changes in state that take place from one frame to the next, a few state
        variables change when the user presses certain keys. In the program, this is checked
        in a method that responds to user keystrokes. If the user presses the left or right
        arrow key, the position of the boat is changed. If the user presses the down
        arrow key, the bomb changes from not-falling to falling. This is coded in the
        <span class="code">keyPressed()</span>method of a <span class="classname">KeyListener</span> that is
        registered to listen for key events on the panel; that method
        reads as follows:</p>


    <pre>public void keyPressed(KeyEvent evt) {
   int code = evt.getKeyCode();  // which key was pressed.
   if (code == KeyEvent.VK_LEFT) {
        // Move the boat left.  (If this moves the boat out of the frame, its
        // position will be adjusted in the boat.updateForNewFrame() method.)
      boat.centerX -= 15;
   }
   else if (code == KeyEvent.VK_RIGHT) {  
        // Move the boat right.  (If this moves boat out of the frame, its
        // position will be adjusted in the boat.updateForNewFrame() method.)
      boat.centerX += 15;
   }
   else if (code == KeyEvent.VK_DOWN) {
         // Start the bomb falling, if it is not already falling.
      if ( bomb.isFalling == false )
         bomb.isFalling = true;
   }
}</pre>


    <p>Note that it's not necessary to call <span class="code">repaint()</span> in this method,
        since this panel shows an animation that is constantly being redrawn
        anyway. Any changes in the state will become visible to the user as soon as the
        next frame is drawn. At some point in the program, I have to make sure that the
        user does not move the boat off the screen. I could have done this in
        <span class="code">keyPressed()</span>, but I choose to check for this in another routine, in
        the boat object.</p>


    <p>The program uses four listeners, to respond to
        action events from the timer, key events from the user, focus events, and
        mouse events. In this program, the user must click the panel to start the game.
        The game is programmed to run as long as the panel has the input focus.
        In this example, the program does not automatically request the focus; the user
        has to do it. When the user clicks the panel, the mouse listener requests the input focus and the
        game begins. The timer runs only when the panel has the input focus; this
        is programmed by having the focus listener start the timer when the panel
        gains the input focus and stop the timer when the panel loses the input focus.
        All four listeners are created in the constructor of the <span class="classname">SubKillerPanel</span>
        class using anonymous inner classes. (See <a href="../c6/s3.html#GUI1.4.5">Subsection&nbsp;6.3.5</a>.)</p>


    <p>I encourage you to read the source code in <span class="sourceref"><a href="../source/chapter6/SubKiller.java">SubKiller.java</a></span>.
        Although a few points are tricky, you should with some effort be able to read and
        understand the entire program. Try to understand the program in terms of state
        machines. Note how the state of each of the three objects in the program changes
        in response to events from the timer and from the user.</p>


    <p>While it's not at all sophisticated as arcade games go, the
        SubKiller game does use some interesting programming. And it
        nicely illustrates how to apply state-machine thinking in event-oriented
        programming.</p>


</div>
<hr>
<div align="right">
    <small>
        [ <a href="s3.html">Previous Section</a> |
        <a href="s5.html">Next Section</a> |
        <a href="index.html">Chapter Index</a> |
        <a href="../index.html">Main Index</a> ]
    </small>
</div>
</body>
</html>
