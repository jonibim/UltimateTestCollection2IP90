<html>
<head>
    <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Javanotes 7.0, Section 13.2 -- Fancier Graphics</title>
    <link type="text/css" rel="stylesheet" href="../javanotes.css">
</head>
<body>
<div align="right">
    <small>
        [ <a href="s1.html">Previous Section</a> |
        <a href="s3.html">Next Section</a> |
        <a href="index.html">Chapter Index</a> |
        <a href="../index.html">Main Index</a> ]
    </small>
</div>
<hr>
<table class="subsections" vspace="8" hspace="8" cellpadding="5" border="2" align="right">
    <tr>
        <td>
            <div align="center">
                <b>Subsections</b>
                <hr>
                <small><a href="#GUI2.2.1">Measuring Text</a>
                    <br>
                    <a href="#GUI2.2.2">Transparency</a>
                    <br>
                    <a href="#GUI2.2.3">Antialiasing</a>
                    <br>
                    <a href="#GUI2.2.4">Strokes and Paints</a>
                    <br>
                    <a href="#GUI2.2.5">Transforms and Shapes</a>
                    <br>
                </small>
            </div>
        </td>
    </tr>
</table>
<div class="content">
    <h3 class="section_title">Section 13.2</h3>
    <h2 class="section_title">Fancier Graphics</h2>
    <hr class="break">


    <p>
        <span class="start"><big>T</big>he graphics commands</span> provided by the <span
            class="classname">Graphics</span>
        class are sufficient for many purposes. However, recent versions of Java provide a much
        larger and richer graphical toolbox in the form of the class <span class="code">java.awt.Graphics2D</span>.
        I mentioned <span class="classname">Graphics2D</span> in <a
            href="../c6/s2.html#GUI1.3.5">Subsection&nbsp;6.2.5</a> and promised
        to discuss it further in this chapter. You have already seen a few of the ideas that
        are covered in this section, at least briefly, but I cover them in more detail here.</p>


    <p>
        <span class="classname">Graphics2D</span> is a subclass of <span class="classname">Graphics</span>, so
        all of the graphics commands that you already know can be used with a <span class="classname">Graphics2D</span>
        object. In fact, when you obtain a <span class="classname">Graphics</span> context for drawing
        on a Swing component, the graphics object is
        actually of type <span class="classname">Graphics2D</span> and can be type-cast to gain access to
        the advanced <span class="classname">Graphics2D</span> graphics commands. Furthermore, <span class="classname">BufferedImage</span>
        has the instance method, <span class="code">createGraphics()</span>, that returns a graphics context of
        type <span class="classname">Graphics2D</span>. As mentioned in <a href="../c6/s2.html#GUI1.3.5">Subsection&nbsp;6.2.5</a>,
        to use <span class="classname">Graphics2D</span> commands in the <span class="code">paintComponent()</span>
        method
        of a Swing component, you can use code of the form:</p>


    <pre>
public void paintComponent(Graphics g) {
   super.paintComponent(g);
   Graphics g2 = (Graphics2D)g;
      .
      .   // Draw to the component using g2 (and g).
      .
}</pre>


    <p>Note that when you do this, <span class="code">g</span> and <span class="code">g2</span> are just two variables
        that refer to the same object, so they both draw to the same drawing surface and have the
        same state. When properties of <span class="code">g2</span>, such as
        drawing color, are changed, the changes also apply to <span class="code">g</span>. By saying</p>


    <pre>Graphics2D g2 = (Graphics2D)<span class="newcode">g.create()</span>;</pre>


    <p>you can obtain a newly created graphics context. The object created by <span class="code">g.create()</span>
        is a graphics context that draws to the same drawing surface as <span class="code">g</span> and that initially
        has all the same properties as <span class="code">g</span>. However, it is a separate object, so that
        changing properties in <span class="code">g2</span> has no effect on <span class="code">g</span>. This can be
        useful
        if you want to keep an unmodified copy of the original graphics context around for some
        drawing operations. (In this case, it is good practice to call <span class="code">g2.dispose()</span>
        to dispose of the new graphics context when you are finished using it.)</p>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="GUI2.2.1">13.2.1&nbsp;&nbsp;Measuring Text</a>
    </h3>


    <p>Although this section is mostly about <span class="classname">Graphics2D</span>, we start
        with a topic that has nothing to do with it.</p>


    <p>Often, when drawing a string, it's important to know how big the image of
        the string will be. For example, you need this information if you want to center a string in
        a component. Or if you want to know how much space to leave between two lines of
        text, when you draw them one above the other. Or if the user is typing the
        string and you want to position a cursor at the end of the string. In Java,
        questions about the size of a string can be answered by an object belonging to the
        standard class <span class="code">java.awt.FontMetrics</span>.</p>


    <p>There are several lengths associated with any given font. Some of them are
        shown in this illustration:</p>


    <p align="center">
        <img src="measuring-strings.png" width="584" height="131"
             alt="Measuring Strings, showing ascent, descent, leading, and lineheight"></p>


    <p>The dashed red lines in the illustration are the <span class="newword">baselines</span>
        of the two lines of text. The baseline of a string is the line on which the bases
        of the characters rest. The suggested distance
        between two baselines, for single-spaced text, is known as the
        <span class="newword">lineheight</span> of the font. The <span class="newword">ascent</span>
        is the distance that tall characters can rise above the
        baseline, and the <span class="newword">descent</span> is the distance that
        tails like the one on the letter "g" can descend below the baseline. The ascent
        and descent do not add up to the lineheight, because there should be some extra
        space between the tops of characters in one line and the tails of characters on
        the line above. The extra space is called <span class="newword">leading</span>.
        (The term comes from the time when lead blocks were used for printing. Characters
        were formed on blocks of lead that were lined up to make up the text of a page,
        covered with ink, and pressed onto paper to print the page.
        Extra, blank "leading" was used to separate the lines of characters.)
        All these quantities can be determined by calling instance methods in a
        <span class="classname">FontMetrics</span> object. There are also methods for determining the width
        of a character and the total width of a string of characters.</p>


    <p>Recall that a font in Java is represented by the class <span class="classname">Font</span>.
        A <span class="classname">FontMetrics</span> object is associated with a given font and
        is used to measure characters and strings in that font.
        If <span class="code">font</span> is of type <span class="classname">Font</span>
        and <span class="code">g</span> is a graphics context, you can get a
        <span class="classname">FontMetrics</span> object for the font by calling
        <span class="code">g.getFontMetrics(font)</span>. If <span class="code">fm</span> is the variable that refers to
        the
        <span class="classname">FontMetrics</span> object, then the ascent, descent, leading, and lineheight
        of the font can be obtained by calling <span class="code">fm.getAscent()</span>,
        <span class="code">fm.getDescent()</span>, <span class="code">fm.getLeading()</span>, and
        <span class="code">fm.getHeight()</span>. If <span class="code">ch</span> is a character, then
        <span class="code">fm.charWidth(ch)</span> is the width of the character when it is drawn in
        that font. If <span class="code">str</span> is a string, then <span class="code">fm.stringWidth(str)</span> is
        the width of the string when drawn in that font.
        For example, here is a <span class="code">paintComponent()</span> method that shows the message
        "Hello World" in the exact center of the component:</p>


    <pre>public void paintComponent(Graphics g) {
   super.paintComponent(g);
   
   int strWidth, strHeight; // Width and height of the string.
   int centerX, centerY;    // Coordinates of the center of the component.
   int baseX, baseY;        // Coordinates of the baseline of the string.
   int topOfString;         // y-coordinate of the top of the string.
   
   centerX = getWidth() / 2;
   centerY = getHeight() / 2;        
   
   Font font = g.getFont();  // What font will g draw in?
   FontMetrics fm = g.getFontMetrics(font);
   strWidth = fm.stringWidth("Hello World");
   strHeight = fm.getAscent();  // Note: There are no tails on and
                                //   of the chars in the string!  So we
                                //   don't need to account for descent.
 
   baseX = centerX - (strWidth/2);  // Move back from center by half the
                                    //    width of the string.
   
   topOfString = centerY - (strHeight/2);  // Move up from center by half
                                           //   the height of the string.
   
   baseY = topOfString + fm.getAscent();  // Baseline is fm.getAscent() pixels
                                          //   below the top of the string.
    
   g.drawString("Hello World", baseX, baseY); // Draw the string.
}</pre>


    <p>For the height of
        the string in this method, I use <span class="code">fm.getAscent()</span>. If I were
        drawing "Goodbye World" instead of "Hello World," I would have used
        <span class="code">fm.getAscent() + fm.getDescent()</span>, where the descent is
        added to the height in order to take into account the tail on the
        "y" in "Goodbye". The value of <span class="code">baseX</span> is computed
        to be the amount of space between the left edge of the component and
        the start of the string. It is obtained by subtracting half the width
        of the string from the horizontal center of the component. This will
        center the string horizontally in the component. The next line computes
        the position of the top of the string in the same way. However, to draw the
        string, we need the y-coordinate of the baseline, not the y-coordinate of
        the top of the string. The baseline of the string is below the top of the
        string by an amount equal to the ascent of the font. </p>


    <p>There is an example of centering a two-line block of text in the
        sample program <span class="sourceref"><a
                href="../source/chapter13/TransparencyDemo.java">TransparencyDemo.java</a></span>, which is discussed in
        the next subsection.</p>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="GUI2.2.2">13.2.2&nbsp;&nbsp;Transparency</a>
    </h3>


    <p>A color is represented by red, blue, and green components. In Java's usual representation,
        each component is an eight-bit number in the range 0 to 255. The three color components can
        be packed into a 32-bit integer, but that only accounts for 24 bits in the integer. What
        about the other eight bits? They don't have to be wasted. They can be used as a fourth
        component of the color, the <span class="newword">alpha component</span>. The alpha component can
        be used in several ways, but it is most commonly associated with <span class="newword">transparency</span>.
        When you draw with a transparent color, it's like laying down a sheet of colored glass. It
        doesn't completely obscure the part of the image that is colored over. Instead, the
        background image is <span class="newword">blended</span> with the transparent color that is
        used for drawing -- as if you were looking at the background through colored glass.
        This type of drawing is properly referred to as <span class="newword">alpha blending</span>, and
        it is not equivalent to true transparency; nevertheless, most people refer to it as
        transparency.</p>


    <p>The value of the alpha component determines how transparent that color is. Actually,
        the alpha component gives the <span class="newword">opaqueness</span> of the color. Opaqueness is
        the opposite of transparency. If something is fully opaque, you can't see through it at all;
        if something is almost fully opaque, then it is just a little transparent; and so on.
        When the alpha component of a color has the maximum possible value, the color is fully
        opaque. When you draw with a fully opaque color, that color simply replaces the
        color of the background over which you draw. Except for a little example in <a href="../c5/s3.html#OOP.3.2">Subsection&nbsp;5.3.3</a>,
        this is the only type of color that we have
        used up until now. If the alpha component of a color is zero, then the color is
        perfectly transparent, and drawing with that color has no effect at all. Intermediate
        values of the alpha component give partially opaque colors that will blend with the
        background when they are used for drawing.</p>


    <p>The sample program <span class="sourceref"><a href="../source/chapter13/TransparencyDemo.java">TransparencyDemo.java</a></span>
        can help you to understand
        transparency. When you run the program you will see a display area containing a triangle,
        an oval, a rectangle, and some text. Sliders at the bottom of the window allow you to control
        the degree of transparency of each shape. When a slider is moved all the way to the
        right, the corresponding shape is fully opaque; all the way to the left, and the shape
        is fully transparent.</p>


    <hr class="break">


    <p>Colors with alpha components were introduced in Java along with <span class="classname">Graphics2D</span>,
        but they can be used with ordinary <span class="classname">Graphics</span> objects as well.
        To specify the alpha component of a color, you can create the <span class="classname">Color</span> object
        using one of the following constructors from the <span class="classname">Color</span> class:</p>


    <pre>public Color(int red, int green, int blue, int alpha);
   
public Color(float red, float green, float blue, float alpha);</pre>


    <p>In the first constructor, all the parameters must be integers in the
        range 0 to 255. In the second, the parameters must be in the range
        0.0 to 1.0. For example,</p>


    <pre>Color transparentRed = new Color( 255, 0, 0, 200 );</pre>


    <p>makes a slightly transparent red, while</p>


    <pre>Color tranparentCyan = new Color( 0.0F, 1.0F, 1.0F, 0.5F);</pre>


    <p>makes a blue-green color that is 50% opaque. (The advantage of
        the constructor that takes parameters of type <span class="ptype">float</span> is
        that it lets you think in terms of percentages.) When you create
        an ordinary RGB color, as in <span class="code">new&nbsp;Color(255,0,0)</span>,
        you just get a fully opaque color.</p>


    <p>Once you have a transparent color, you can use it in the same way
        as any other color. That is, if you want to use a <span class="classname">Color</span>
        <span class="code">c</span> to draw in a graphics context <span class="code">g</span>, you just
        say <span class="code">g.setColor(c)</span>, and subsequent drawing operations
        will use that color. As you can see, transparent colors are very
        easy to use.</p>


    <hr class="break">


    <p>A <span class="classname">BufferedImage</span> with image type <span
            class="code">BufferedImage.TYPE_INT_ARGB</span>
        can use transparency. The color of each pixel in the image can have its own
        alpha component, which tells how transparent that pixel will be when the image is
        drawn over some background. A pixel whose alpha component is zero is perfectly transparent,
        and has no effect at all when the image is drawn; in effect, it's not part of the image at all.
        It is also possible for pixels to be partly transparent. When an image is saved to a file,
        information about transparency might be lost, depending on the file format. The PNG
        image format supports transparency; JPEG does not. (If you look at the images of playing
        cards that are used in the program <span class="code">HighLowWithImages</span> in
        <a href="../c13/s1.html#GUI2.1.1">Subsection&nbsp;13.1.1</a>, you might notice that the tips of the corners of
        the cards are fully
        transparent. The card images are from a PNG file, <span class="sourceref"><a
                href="../source/chapter13/cards.png">cards.png</a></span>.)</p>


    <p>An ARGB <span class="classname">BufferedImage</span> should be fully transparent when it is
        first created, but if you want to make sure, here is one way of doing so:
        The <span class="classname">Graphics2D</span>
        class has a method <span class="code">setBackground()</span> that can be used to set a background
        color for the graphics context, and it has a <span class="code">clearRect()</span> method that
        fills a rectangle with the current background color. To create a fully transparent
        image with width <span class="code">w</span> and height <span class="code">h</span>, you can use:</p>


    <pre>BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
Graphics2D g2 = image.createGraphics();
g2.setBackground(new Color(0,0,0,0));  // (The R, G, and B values don't matter.)
g2.clearRect(0, 0, w, h);</pre>


    <p>(Note that simply drawing with a transparent color will not make pixels in the
        image transparent. The alpha component of a <span class="classname">Color</span> makes
        the color transparent when it is used for drawing; it does not change the
        transparency of the pixels that are modified by the drawing operation.)</p>


    <p>As an example, just for fun, here is a method that will set the cursor of a component
        to be a red square with a transparent interior:</p>


    <pre>private void useRedSquareCursor() {
   BufferedImage image = new BufferedImage(24,24,BufferedImage.TYPE_INT_ARGB);
   Graphics2D g2 = image.createGraphics();
   g2.setBackground(new Color(0,0,0,0));
   g2.clearRect(0, 0, 24, 24);  // (should not be necessary in a new image)
   g2.setColor(Color.RED);
   g2.drawRect(0,0,23,23); // draw a red border of width 3 around the square
   g2.drawRect(1,1,21,21);
   g2.drawRect(2,2,19,19);
   g2.dispose();
   Point hotSpot = new Point(12,12);
   Toolkit tk = Toolkit.getDefaultToolkit();
   Cursor cursor = tk.createCustomCursor(image,hotSpot,"square");
   setCursor(cursor);
}</pre>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="GUI2.2.3">13.2.3&nbsp;&nbsp;Antialiasing</a>
    </h3>


    <p>To draw a geometric figure such as a line or circle, you just have to
        color the pixels that are part of the figure, right? Actually, there is
        a problem with this. Pixels are little squares. Geometric figures, on
        the other hand, are made of geometric points that have no size at all.
        Think about drawing a circle, and think about a pixel on the boundary
        of that circle. The infinitely thin geometric boundary of the circle
        cuts through the pixel. Part of the pixel lies inside the circle,
        part lies outside. So, when we are filling the circle with color,
        do we color that pixel or not? A possible solution is to color
        the pixel if the geometric circle covers 50% or more of the pixel.
        Following this procedure, however, leads to a visual defect
        known as <span class="newword">aliasing</span>. It is visible in images
        as a jaggedness or "staircasing" effect along the borders of curved
        shapes. Lines that are not horizontal or vertical also have a jagged,
        aliased appearance. (The term "aliasing" seems to refer to the fact
        that many different geometric points map to the same pixel. If you
        think of the real-number coordinates of a geometric point as a "name" for
        the pixel that contains that point, then each pixel has many different
        names or "aliases.")</p>


    <p>It's not possible to build a circle out of squares, but there is
        a technique that can eliminate some of the jaggedness of aliased images. The
        technique is called <span class="newword">antialiasing</span>. Antialiasing is
        based on transparency. The idea is simple: If 50% of a pixel is
        covered by the geometric figure that you are trying to draw, then
        color that pixel with a color that is 50% transparent. If 25% of the
        pixel is covered, use a color that is 75% transparent (25% opaque).
        If the entire pixel is covered by the figure, of course, use a color
        that is 100% opaque -- antialiasing only affects pixels that are only
        partly covered by the geometric shape.</p>


    <p>In antialiasing, the color that you are drawing
        with is blended with the original color of the pixel, and the amount
        of blending depends on the fraction of the pixel that is covered by
        the geometric shape. (The fraction is difficult to compute exactly,
        so in practice, various methods are used to approximate it.) Of course,
        you still don't get a picture of the exact geometric shape, but antialiased
        images do tend to look better than jagged, aliased images.</p>


    <p>For an example, look at the picture in the
        next subsection. Antialiasing is used to draw the panels in the second
        and third row of the picture, but it is not
        used in the top row. You should note the jagged appearance of the lines
        in the top row. (By the way, when antialiasing is applied
        to a line, the line is treated as a geometric rectangle whose width
        is equal to the line width.)</p>


    <p>Antialiasing is supported in <span class="classname">Graphics2D</span>. By
        default, antialiasing is turned off. If <span class="code">g2</span> is a graphics
        context of type <span class="classname">Graphics2D</span>, you can turn on
        antialiasing in <span class="code">g2</span> by saying:</p>


    <pre>g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                                  RenderingHints.VALUE_ANTIALIAS_ON);</pre>


    <p>As you can see, this is only a "hint" that you would like to use
        antialiasing, and it is even possible that the hint will be ignored.
        However, it is likely that subsequent drawing operations in <span class="code">g2</span>
        will be antialiased. If you want to turn antialiasing off in
        <span class="code">g2</span>, you should say:</p>


    <pre>g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                                  RenderingHints.VALUE_ANTIALIAS_OFF);</pre>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="GUI2.2.4">13.2.4&nbsp;&nbsp;Strokes and Paints</a>
    </h3>


    <p>When using the <span class="classname">Graphics</span> class, any line that you
        draw will be a solid line that is one pixel thick. The <span class="classname">Graphics2D</span>
        class makes it possible to draw a much greater variety of lines. You can draw
        lines of any thickness, and you can draw lines that are dotted or dashed instead
        of solid.</p>


    <p>An object of type <span class="classname">Stroke</span> contains information about how
        lines should be drawn, including how thick the line should be and what pattern of
        dashes and dots, if any, should be used. Every <span class="classname">Graphics2D</span>
        has an associated <span class="classname">Stroke</span> object. The default <span
                class="classname">Stroke</span>
        draws a solid line of thickness one. To get lines with different properties, you
        just have to install a different stroke into the graphics context.</p>


    <p>
        <span class="classname">Stroke</span> is an <span class="code">interface</span>, not a class. The class
        <span class="classname">BasicStroke</span>, which implements the <span class="code">Stroke</span> interface,
        is the one that is actually used to create stroke objects. For example, to
        create a stroke that draws solid lines with thickness equal to 3, use:</p>


    <pre>BasicStroke line3 = new BasicStroke(3);</pre>


    <p>If <span class="code">g2</span> is of type <span class="classname">Graphics2D</span>, the stroke can be
        installed in <span class="code">g2</span> by calling its <span class="code">setStroke()</span> command:</p>


    <pre>g2.setStroke(line3)</pre>


    <p>After calling this method, subsequent drawing operations will use lines that are
        three times as wide as the usual thickness.
        The thickness of a line can be given by a value of type <span class="ptype">float</span>,
        not just by an <span class="ptype">int</span>. For example, to use lines of thickness
        2.5 in the graphics context <span class="code">g2</span>, you can say:</p>


    <pre>g2.setStroke( new BasicStroke(2.5F) );</pre>


    <p>(Fractional widths make more sense if antialiasing is turned on.)</p>


    <p>When you have a thick line, the question comes up, what to do at the ends
        of the line. If you draw a physical line with a large, round piece of chalk, the
        ends of the line will be rounded. When you draw a line on the computer
        screen, should the ends be rounded, or should the line simply be cut off
        flat? With the <span class="classname">BasicStroke</span> class, the choice is up to you.
        Maybe it's time to look at examples. This illustration
        shows fifteen lines, drawn using different <span class="classname">BasicStrokes</span>.
        Lines in the middle row have rounded ends; lines in the other two rows are
        simply cut off at their endpoints. Lines of various thicknesses are shown,
        and the bottom row shows dashed lines. (And, as mentioned above, only the
        bottom two rows are antialiased.)</p>


    <p align="center">
        <img src="stroke-demo.png" width="518" height="312" alt="lines drawn with various BasicStrokes"></p>


    <p>This illustration is a screenshot from the sample program <span class="sourceref"><a
            href="../source/chapter13/StrokeDemo.java">StrokeDemo.java</a></span>.
        In that program, you can click and drag
        in any of the small panels, and the lines in all the panels will be redrawn
        as you move the mouse. In addition, if you right-click and drag, then
        rectangles will be drawn instead of lines; this shows that strokes are used
        for drawing the outlines of shapes and not just for straight lines.
        If you look at the corners of the rectangles that are drawn by the program,
        you'll see that there are several ways of drawing a corner where two wide
        line segments meet.</p>


    <p>All the options that you want for a <span class="classname">BasicStroke</span> have
        to be specified in the constructor. Once the stroke object is created, there
        is no way to change the options. There is one constructor that lets you specify
        all possible options:</p>


    <pre>public BasicStroke( float width, int capType, int joinType, float miterlimit,
                                         float[] dashPattern, float dashPhase )</pre>


    <p>I don't want to cover all the options in detail, but here's some basic
        info:</p>


    <ul>

        <li>
            <span class="code">width</span> specifies the thickness of the line
        </li>

        <li>
            <span class="code">capType</span> specifies how the ends of a line are "capped." The
            possible values are <span class="code">BasicStroke.CAP_SQUARE</span>, <span class="code">BasicStroke.CAP_ROUND</span>
            and <span class="code">BasicStroke.CAP_BUTT</span>. These values are used, respectively, in the
            first, second, and third rows of the above picture.
            The default is <span class="code">BasicStroke.CAP_SQUARE</span>.
        </li>

        <li>
            <span class="code">joinType</span> specifies how two line segments are joined together at
            corners. Possible values are <span class="code">BasicStroke.JOIN_MITER</span>,
            <span class="code">BasicStroke.JOIN_ROUND</span>, and <span class="code">BasicStroke.JOIN_BEVEL</span>.
            Again, these are used in the three rows of panels in the sample program;
            you will only see the effect if you run the program and draw some rectangles.
            The default is <span class="code">BasicStroke.JOIN_MITER</span>.
        </li>

        <li>
            <span class="code">miterLimit</span> is used only if the value of <span class="code">joinType</span> is
            <span class="code">JOIN_MITER</span>; just use the default value, <span class="code">10.0F</span>.
        </li>

        <li>
            <span class="code">dashPattern</span> is used to specify dotted and dashed lines. The
            values in the array specify lengths in the dot/dash pattern. The numbers in the
            array represent the length of a solid
            piece, followed by the length of a transparent piece, followed by the length of
            a solid piece, and so on. At the end of the array, the pattern wraps back to the
            beginning of the array. If you want a solid line, use a different
            constructor that has fewer parameters.
        </li>

        <li>
            <span class="code">dashPhase</span> tells the computer where to start in the <span
                class="code">dashPattern</span>
            array, for the first segment of the line. Use 0 for this parameter in most cases.
        </li>

    </ul>


    <p>For the third row in the above picture, the
        <span class="code">dashPattern</span> is set to <span class="code">new&nbsp;float[]&nbsp;{5,5}</span>.
        This means that the lines are drawn starting with a solid segment of length 5,
        followed by a transparent section of length 5, and then repeating the same pattern.
        A simple dotted line would have thickness 1 and <span class="code">dashPattern</span>
        <span class="code">new&nbsp;float[]&nbsp;{1,1}</span>. A pattern of short and long dashes
        could be made by using <span class="code">new&nbsp;float[]&nbsp;{10,4,4,4}</span>.
        For more information, see the Java documentation, or try experimenting
        with the source code for the sample program.</p>


    <hr class="break">


    <p>So now we can draw fancier lines. But any drawing operation is still
        restricted to drawing with a single color. We can get around that restriction
        by using <span class="classname">Paint</span>. An object of type <span class="classname">Paint</span>
        is used to assign color to each pixel that is "hit" by a drawing operation.
        <span class="classname">Paint</span> is an <span class="code">interface</span>, and the <span class="classname">Color</span>
        class implements the <span class="classname">Paint</span> interface. When a color is used
        for painting, it applies the same color to every pixel that is hit.
        However, there are other types of paint where the color that is applied to
        a pixel depends on the coordinates of that pixel. Standard Java includes several
        classes that define paint with this property: <span class="classname">TexturePaint</span>
        and several types of gradient paint. In a <span class="newword">texture</span>,
        the pixel colors come from an image, which is repeated, if necessary, like a wallpaper pattern
        to cover the entire xy-plane. In a <span class="newword">gradient</span>,
        the color that is applied to pixels changes gradually from one color to another
        color as you move from point to point. Java has three types of gradient paints:
        <span class="classname">GradientPaint</span>, <span class="classname">LinearGradientPaint</span>,
        and <span class="classname">RadialGradientPaint</span>.</p>


    <p>It will be helpful to look at some examples. This illustration shows a polygon
        filled with two different paints. The polygon on the left uses a <span class="classname">GradientPaint</span>
        while the one on the right uses a <span class="classname">TexturePaint</span>. Note that in this picture,
        the paint is used only for filling
        the polygon. The outline of the polygon is drawn in a plain black color. However,
        <span class="classname">Paint</span> objects can be used for drawing lines as well as
        for filling shapes. These pictures were made by the sample program
        <span class="sourceref"><a href="../source/chapter13/PaintDemo.java">PaintDemo.java</a></span>. In that program,
        you can select among several
        different paints, and you can control certain properties of the paints.</p>


    <p align="center">
        <img src="paint-demo.png" width="570" height="219" alt="two types of paint, gradient fill and texture fill"
             class="bordered"></p>


    <p>Basic gradient paints are created using the constructor</p>


    <pre>public GradientPaint(float x1, float y1, Color c1,
                             float x2, float y2, Color c2, boolean cyclic)</pre>


    <p>This constructs a gradient that has color <span class="code">c1</span> at the
        point with coordinates <span class="code">(x1,y1)</span> and color <span class="code">c2</span> at the point
        <span class="code">(x2,y2)</span>. As you move along the line between the two points,
        the color of the gradient changes from <span class="code">c1</span> to <span class="code">c2</span>;
        along lines perpendicular to this line, the color is constant. The
        last parameter, <span class="code">cyclic</span>, tells what happens if you move past the
        point <span class="code">(x2,y2)</span> on the line from <span class="code">(x1,y1)</span> to <span
                class="code">(x2,y2)</span>.
        If <span class="code">cyclic</span> is <span class="code">false</span>, the color stops changing and any point
        beyond
        <span class="code">(x2,y2)</span> has color <span class="code">c2</span>. If <span class="code">cyclic</span> is
        <span class="code">true</span>,
        then the colors continue to change in a cyclic pattern after you move past
        <span class="code">(x2,y2)</span>. (It works the same way if you move past the other
        endpoint, <span class="code">(x1,y1)</span>.) In most cases, you will set <span class="code">cyclic</span>
        to <span class="code">true</span>. Note that you can vary the points <span class="code">(x1,y1)</span>
        and <span class="code">(x2,y2)</span> to change the width and direction of the gradient.
        For example, to create a cyclic gradient that varies from black to light gray along the line
        from <span class="code">(0,0)</span> to <span class="code">(100,100)</span>, use:</p>


    <pre>new GradientPaint( 0, 0, Color.BLACK, 100, 100, Color.LIGHT_GRAY, true)</pre>


    <p>The other two gradient paint classes, <span class="classname">LinearGradientPaint</span>
        and <span class="classname">RadialGradientPaint</span>, are more sophisticated.
        Linear gradient paints are similar to
        <span class="classname">GradientPaint</span> but can be based on more than two colors. Radial gradients
        color pixels based on their distance from a central point, which produces rings of constant
        color instead of lines of constant color. See the API documentation for details.</p>


    <hr class="break">


    <p>To construct a <span class="classname">TexturePaint</span>, you need a <span
            class="classname">BufferedImage</span>
        that contains the image that will be used for the texture. You also specify a rectangle
        in which the image will be drawn. The image will be scaled, if necessary, to exactly fill
        the rectangle. Outside the specified rectangle, the image will be repeated horizontally
        and vertically to fill the plane. You can vary the size and position of the rectangle
        to change the scale of the texture and its positioning on the plane. Ordinarily, however
        the upper left corner of the rectangle is placed at <span class="code">(0,0)</span>, and the size of the
        rectangle
        is the same as the actual size of the image. The constructor for <span class="classname">TexturePaint</span>
        is defined as</p>


    <pre>public TexturePaint( BufferedImage textureImage, Rectangle2D anchorRect)</pre>


    <p>The <span class="classname">Rectangle2D</span> class is part of the <span class="classname">Graphics2D</span>
        framework and will be discussed at the end of this section. Often, a call to the
        constructor takes the following form, which will show the image at its actual size:</p>


    <pre>new TexturePaint( image,
            new Rectangle2D.Double(0,0,image.getWidth(),image.getHeight() )</pre>


    <p>Once you have a <span class="classname">Paint</span> object, you can use the
        <span class="code">setPaint()</span> method of a <span class="classname">Graphics2D</span> object
        to install the paint in a graphics context. For example, if <span class="code">g2</span>
        is of type <span class="classname">Graphics2D</span>, then the command</p>


    <pre>g2.setPaint( new GradientPaint(0,0,Color.BLUE,100,100,Color.GREEN,true) );</pre>


    <p>sets up <span class="code">g2</span> to use a gradient paint. Subsequent drawing operations
        with <span class="code">g2</span> will draw using a blue/green gradient.</p>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="GUI2.2.5">13.2.5&nbsp;&nbsp;Transforms and Shapes</a>
    </h3>


    <p>In the standard drawing coordinates on a component, the upper left corner
        of the component has coordinates <span class="code">(0,0)</span>. Coordinates are integers, and the
        coordinates <span class="code">(x,y)</span> refer to the point that is <span class="code">x</span> pixels
        over from the left edge of the component and <span class="code">y</span> pixels down from
        the top. With <span class="classname">Graphics2D</span>, however, you are not
        restricted to using these coordinates. In fact, you can can set up
        a <span class="classname">Graphics2D</span> graphics context to use any system
        of coordinates that you like. You can use this capability to select the
        coordinate system that is most appropriate for the things that you want to
        draw. For example, if you are drawing architectural blueprints, you might
        use coordinates in which one unit represents an actual distance of one foot.
    </p>


    <p>Changes to a coordinate system are referred to as <span class="newword">transforms</span>.
        There are three basic types of transform. A <span class="newword">translate</span> transform
        changes the position of the origin, <span class="code">(0,0)</span>. A <span class="newword">scale</span>
        transform changes
        the scale, that is, the unit of distance. And a <span class="newword">rotation</span> transform
        applies a rotation about some point. You can make more complex transforms by
        combining transforms of the three basic types. For example, you can apply a
        rotation, followed by a scale, followed by a translation, followed by another
        rotation. When you apply several transforms in a row, their effects are cumulative.
        It takes a fair amount of study to fully understand complex transforms, and
        transforms are a major topic in a course in computer graphics.
        I will limit myself here to discussing a few of the most simple cases, just to
        give you an idea of what transforms can do.</p>


    <p>Suppose that <span class="code">g2</span> is of type <span class="classname">Graphics2D</span>.
        Then <span class="code">g2.translate(x,y)</span> moves the origin, <span class="code">(0,0)</span>, to the point
        <span class="code">(x,y)</span>.
        This means that if you use coordinates <span class="code">(0,0)</span> <b>after</b> saying <span class="code">g2.translate(x,y)</span>,
        then you are referring to the point that <i>used to be</i> <span class="code">(x,y)</span>, before
        the translation was applied. All other coordinate pairs are moved by the same amount.
        For example saying</p>


    <pre>g.translate(x,y);
g.drawLine( 0, 0, 100, 200 );</pre>


    <p>draws the same line as</p>


    <pre>g.drawLine( x, y, 100+x, 200+y );</pre>


    <p>In the second case, you are just doing the same translation "by hand."
        A translation (like all transforms) affects all subsequent drawing operations.
        Instead of thinking in terms of coordinate systems, you might find it clearer
        to think of what happens to the objects that are drawn. After you say
        <span class="code">g2.translate(x,y)</span>, any objects that you draw are displaced <span class="code">x</span>
        units horizontally and <span class="code">y</span> units vertically.
        Note that the parameters <span class="code">x</span> and <span class="code">y</span> can be real numbers.</p>


    <p>As an example, perhaps you would prefer to have <span class="code">(0,0)</span> at the center of a
        component, instead of at its upper left corner. To do this, just use the
        following command in the <span class="code">paintComponent()</span> method of the component:</p>


    <pre>g2.translate( getWidth()/2, getHeight()/2 );</pre>


    <p>To apply a scale transform to a <span class="classname">Graphics2D</span> <span class="code">g2</span>,
        use <span class="code">g2.scale(s,s)</span>, where <span class="code">s</span> is the real number that specifies
        the scaling factor. If <span class="code">s</span> is greater than 1, everything is magnified
        by a factor of <span class="code">s</span>, while if <span class="code">s</span> is between 0 and 1,
        everything is shrunk by a factor of <span class="code">s</span>. The center of scaling is
        <span class="code">(0,0)</span>. That is, the point <span class="code">(0,0)</span> is unaffected by the
        scaling, and other points
        move toward or away from <span class="code">(0,0)</span> by a factor of&nbsp;<span class="code">s</span>. Again,
        it can be clearer to think of the effect on objects that are drawn after a
        scale transform is applied. Those objects will be magnified or shrunk by
        a factor of&nbsp;<span class="code">s</span>. Note that scaling affects <b>everything</b>,
        including thickness of lines and size of fonts. It is possible to use different scale
        factors in the horizontal and vertical direction with a command of the form
        <span class="code">g2.scale(sx,sy)</span>, although that will distort the shapes of objects.
        By the way, it is even possible to use scale factors that are less than&nbsp;0,
        which results in reflections. For example, after calling <span class="code">g2.scale(-1,1)</span>,
        objects will be reflected horizontally through the line <span class="code">x=0</span>.
    </p>


    <p>The third type of basic transform is rotation. The command <span class="code">g2.rotate(r)</span>
        rotates all subsequently drawn objects through an angle of <span class="code">r</span> about the
        point <span class="code">(0,0)</span>. You can rotate instead about the point <span class="code">(x,y)</span>
        with the command <span class="code">g2.rotate(r,x,y)</span>. All the parameters can be real
        numbers. Angles are measured in radians, where Ï€ radians are equal to 180 degrees.
        To rotate through an angle of <span class="code">d</span> degrees, use</p>


    <pre>g2.rotate( d * Math.PI / 180 );</pre>


    <p>Positive angles are clockwise rotations, while negative angles are
        counterclockwise (unless you have applied a negative scale factor,
        which reverses the orientation).</p>


    <p>Rotation is not as common as translation or scaling, but there are a few things
        that you can do with it that can't be done any other way. For example, you can
        use it to draw an image "on the slant." Rotation also makes it possible to draw text
        that is rotated so that its baseline is slanted or even vertical. To draw the
        string "Hello World" with its basepoint at <span class="code">(x,y)</span> and rising at
        an angle of 30 degrees, use:</p>


    <pre>g2.rotate( -30 * Math.PI / 180, x, y );
g2.drawString( "Hello World", x, y );</pre>


    <p>To draw the message vertically, with the <b>center</b> of its baseline
        at the point <span class="code">(x,y)</span>, we can use <span class="classname">FontMetrics</span>
        to measure the string, and say:</p>


    <pre>FontMetrics fm = g2.getFontMetrics( g2.getFont() );
int baselineLength = fm.stringWidth("Hello World");
g2.rotate( -90 * Math.PI / 180, x, y);
g2.drawString( "Hello World", x - baselineLength/2, y );</pre>


    <hr class="break">


    <p>The drawing operations in the <span class="classname">Graphics</span> class use
        integer coordinates only. <span class="classname">Graphics2D</span> makes it
        possible to use real numbers as coordinates. This becomes particularly important
        once you start using transforms, since after you apply a scaling transform, a square of size
        one might cover many pixels instead of just a single pixel. Unfortunately, the
        designers of Java couldn't decide whether to use numbers of type <span class="ptype">float</span>
        or <span class="ptype">double</span> as coordinates, and their indecision makes things a
        little more complicated than they need to be. (My guess is that they really
        wanted to use <span class="ptype">float</span>, since values of type float have enough
        accuracy for graphics and are probably used in the underlying graphical computations
        of the computer. However, in Java programming, it's easier to use <span class="ptype">double</span>
        than <span class="ptype">float</span>, so they wanted to make it possible to use
        <span class="ptype">double</span> values too.)</p>


    <p>To use real number coordinates, you have to use classes defined in the
        package <span class="code">java.awt.geom</span>. Among the classes in this package are classes that
        represent geometric shapes such as lines and rectangles. For example,
        the class <span class="classname">Line2D</span> represents a line whose endpoints
        are given as real number coordinates. The unfortunate thing is that
        <span class="classname">Line2D</span> is an abstract class, which means that you can't
        create objects of type <span class="classname">Line2D</span> directly. However,
        <span class="classname">Line2D</span> has two concrete subclasses that can be
        used to create objects. One subclass uses coordinates of type <span class="ptype">float</span>,
        and one uses coordinates of type <span class="ptype">double</span>. The most peculiar part is
        that these subclasses are defined as static nested classes inside <span class="classname">Line2D</span>.
        Their names are <span class="classname">Line2D.Float</span> and <span class="classname">Line2D.Double</span>.
        This means that <span class="classname">Line2D</span> objects can be created, for example, with:</p>


    <pre>Line2D line1 = new Line2D.Float( 0.17F, 1.3F, -2.7F, 5.21F );
Line2D line2 = new Line2D.Double( 0, 0, 1, 0);
Line2D line3 = new Line2D.Double( x1, y1, x2, y2 );</pre>


    <p>where <span class="code">x1</span>, <span class="code">y1</span>, <span class="code">x2</span>, <span
            class="code">y2</span> are
        any numeric variables. In my own code, I generally use <span class="classname">Line2D.Double</span>
        rather than <span class="classname">Line2D.Float</span>.</p>


    <p>Other shape classes in <span class="code">java.awt.geom</span> are similar. The class that
        represents rectangles is <span class="classname">Rectangle2D</span>. To create a rectangle
        object, you have to use either <span class="classname">Rectangle2D.Float</span> or
        <span class="classname">Rectangle2D.Double</span>. For example,</p>


    <pre>Rectangle2D rect = new Rectangle2D.Double( -0.5, -0.5, 1.0, 1.0 );</pre>


    <p>creates a rectangle with a corner at <span class="code">(-0.5,-0.5)</span> and with
        width and height both equal to&nbsp;1. Other classes include <span class="classname">Point2D</span>,
        which represents a single point; <span class="classname">Ellipse2D</span>, which represents
        an oval; and <span class="classname">Arc2D</span>, which represents an arc of a circle.</p>


    <p>If <span class="code">g2</span> is of type <span class="classname">Graphics2D</span> and <span
            class="code">shape</span>
        is an object belonging to one of the 2D shape classes, then the command</p>


    <pre>g2.draw(shape);</pre>


    <p>draws the shape. For a shape such as a rectangle or ellipse that has an interior,
        only the outline is drawn. To fill in the interior of such a shape, use</p>


    <pre>g2.fill(shape)</pre>


    <p>For example, to draw a line from <span class="code">(x1,y1)</span> to <span class="code">(x2,y2)</span>,
        use</p>


    <pre>g2.draw( new Line2D.Double(x1,y1,x2,y2) );</pre>


    <p>and to draw a filled rectangle with a corner at <span class="code">(3.5,7)</span>, with width 5
        and height 3, use</p>


    <pre>g2.fill( new Rectangle2D.Double(3.5, 7, 5, 3) );</pre>


    <p>The package <span class="code">java.awt.geom</span> also has a very nice class <span
            class="classname">Path2D</span>
        that can be used to draw polygons and curves defined by any number of points. See the
        Java documentation if you want to find out how to use it. </p>


    <p>This section has introduced you to many of the interesting features of <span class="classname">Graphics2D</span>,
        but there is still a large part of the <span class="classname">Graphics2D</span> framework for you to explore.
    </p>


</div>
<hr>
<div align="right">
    <small>
        [ <a href="s1.html">Previous Section</a> |
        <a href="s3.html">Next Section</a> |
        <a href="index.html">Chapter Index</a> |
        <a href="../index.html">Main Index</a> ]
    </small>
</div>
</body>
</html>
