<html>
<head>
    <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Javanotes 7.0, Section 13.4 -- Complex Components and MVC</title>
    <link type="text/css" rel="stylesheet" href="../javanotes.css">
</head>
<body>
<div align="right">
    <small>
        [ <a href="s3.html">Previous Section</a> |
        <a href="s5.html">Next Section</a> |
        <a href="index.html">Chapter Index</a> |
        <a href="../index.html">Main Index</a> ]
    </small>
</div>
<hr>
<table class="subsections" vspace="8" hspace="8" cellpadding="5" border="2" align="right">
    <tr>
        <td>
            <div align="center">
                <b>Subsections</b>
                <hr>
                <small><a href="#GUI2.4.1">Model-View-Controller</a>
                    <br>
                    <a href="#GUI2.4.2">Lists and ListModels</a>
                    <br>
                    <a href="#GUI2.4.3">Tables and TableModels</a>
                    <br>
                    <a href="#GUI2.4.4">Documents and Editors</a>
                    <br>
                    <a href="#GUI2.4.5">Custom Components</a>
                    <br>
                </small>
            </div>
        </td>
    </tr>
</table>
<div class="content">
    <h3 class="section_title">Section 13.4</h3>
    <h2 class="section_title">Complex Components and MVC</h2>
    <hr class="break">


    <p>
        <span class="start"><big>S</big>ince even buttons</span> turn out to be pretty complex, as seen
        in the <a href="../c13/s3.html">previous section</a>, you might guess that there
        is a lot more complexity lurking in the Swing API. While this is true, a lot of that
        complexity works to your benefit as a programmer, since a lot of it is hidden in
        normal uses of Swing components. For example, you don't have to know about all the
        complex details of buttons in order to use them effectively in most programs.</p>


    <p>Swing defines several component classes that are much more complex than those
        we have looked at so far, but even the most complex components are not very
        difficult to use for many purposes. In this section, we'll look at components
        that support display and manipulation of lists, tables, and text documents.
        To use these complex components effectively, you'll need to know something about
        the Model-View-Controller pattern that is used as a basis for the design of
        many Swing components. This pattern is discussed in the first part of this section.</p>


    <p>This section is our last look at Swing components, but there are a number of
        component classes that have not even been touched on in this book. Some useful
        ones that you might want to look into include: <span class="classname">JTabbedPane</span>,
        <span class="classname">JSplitPane</span>, <span class="classname">JTree</span>, <span class="classname">JSpinner</span>,
        <span class="classname">JPopupMenu</span>, <span class="classname">JProgressBar</span>, and
        <span class="classname">JScrollBar</span>.</p>


    <p>At the end of the section, we'll look briefly at the idea of writing custom
        component classes -- something that you might consider when
        even the large variety of components that are already
        defined in Swing don't do quite what you want (or when they do too much,
        and you want something simpler).</p>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="GUI2.4.1">13.4.1&nbsp;&nbsp;Model-View-Controller</a>
    </h3>


    <p>One of the principles of object-oriented design is division of responsibilities.
        Ideally, an object should have a single, clearly defined role, with a limited
        realm of responsibility. One application of this principle to the design of
        graphical user interfaces is the <span class="newword">MVC pattern</span>. "MVC" stands
        for "Model-View-Controller" and refers to three different realms of responsibility
        in the design of a graphical user interface.</p>


    <p>When the MVC pattern is applied to a component, the <span class="newword">model</span>
        consists of the data that represents the current state of the component.
        The <span class="newword">view</span> is simply the visual presentation of the
        component on the screen. And the <span class="newword">controller</span> is the
        aspect of the component that carries out actions in response to events
        generated by the user (or by other sources such as timers). The idea is to assign responsibility for the
        model, the view, and the controller to different objects.</p>


    <p>The view is the easiest part of the MVC pattern to understand. It is
        often represented by the component object itself, and its responsibility
        is to draw the component on the screen. In doing this, of course, it
        has to consult the model, since the model represents the state of the
        component, and that state can determine what appears on the screen.
        To get at the model data -- which is stored in a separate object
        according to the MVC pattern -- the component object needs to keep
        a reference to the model object. Furthermore, when the model changes,
        the view often needs to be redrawn to reflect the changed state.
        The component needs some way of knowing when changes in the model
        occur. Typically, in Java, this is done with events and listeners. The
        model object is set up to generate events when its data changes.
        The view object registers itself as a listener for those events. When the model
        changes, an event is generated, the view is notified of that event, and the
        view responds by updating its appearance on the screen.</p>


    <p>When MVC is
        used for Swing components, the controller is generally not so well defined
        as the model and view, and its responsibilities are often split
        among several objects. The controller might include mouse
        and keyboard listeners that respond to user events on the view;
        <span class="classname">Actions</span> that respond to menu commands or buttons;
        and listeners for other high-level events, such as those from a slider,
        that affect the state of the component. Usually, the controller
        responds to events by making modifications to the model, and
        the view is changed only indirectly, in response to the changes
        in the model.</p>


    <p>The MVC pattern is used in many places in the design of Swing.
        It is even used for buttons. The state of a Swing button is
        stored in an object of type <span class="classname">ButtonModel</span>.
        The model stores such information as whether the button is enabled,
        whether it is selected, and what <span class="classname">ButtonGroup</span>
        it is part of, if any. If <span class="code">button</span> is of type
        <span class="classname">JButton</span> (or one of the other subclasses
        of <span class="classname">AbstractButton</span>), then its
        <span class="classname">ButtonModel</span> can be obtained by calling
        <span class="code">button.getModel()</span>. In the case of buttons, you
        might never need to use the model or even know that it exists.
        But for the list and table components that we will look at
        next, knowledge of the model is essential.</p>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="GUI2.4.2">13.4.2&nbsp;&nbsp;Lists and ListModels</a>
    </h3>


    <p>A <span class="classname">JList</span> is a component that represents a list
        of items that can be selected by the user. The sample program
        <span class="sourceref"><a href="../source/chapter13/SillyStamper.java">SillyStamper.java</a></span> allows the
        user to select
        one icon from a <span class="classname">JList</span> of <span class="classname">Icons</span>.
        The user selects an icon from the list by clicking on it.
        The selected icon can be "stamped" onto a drawing area by clicking on
        the drawing area. (The icons in this program are from the KDE desktop project.)
        Here
        is a picture of the program with several icons already stamped onto the
        drawing area and with the "star" icon selected:</p>


    <p align="center">
        <img src="silly-stamper.png" width="458" height="341" alt="screenshot from SillyStamper.java"></p>


    <p>Note that the scrollbar in this program is not part of the <span class="classname">JList</span>.
        To add a scrollbar to a list, the list must be placed into a <span class="classname">JScrollPane</span>.
        See <a href="../c6/s5.html#GUI1.6.4">Subsection&nbsp;6.5.4</a>, where the use of <span class="classname">JScrollPane</span>
        to
        hold a <span class="classname">JTextArea</span> was discussed. Scroll panes are used in the
        same way with lists and with other components. In this case, the <span class="classname">JList</span>,
        <span class="code">iconList</span>, was added to a scroll pane and the scroll pane was added to
        a panel with the single command:</p>


    <pre>add( new JScrollPane(iconList), BorderLayout.EAST );</pre>


    <p>
        <span class="classname">JList</span> is a parameterized
        type, where the type parameter indicates what type of object can be displayed in the list.
        The most common types are <span class="atype">JList&lt;String&gt;</span> and <span class="atype">JList&lt;Icon&gt;</span>.
        Other types can be used, but they will be converted to strings for display.
        (It's possible to "teach" a <span class="classname">JList</span> how to display other types of items;
        see the <span class="code">setCellRenderer()</span> method in the <span class="classname">JList</span>
        class.)</p>


    <p>One way to construct a <span class="classname">JList</span> is from an array that contains
        the objects that will appear in the list. In the <span class="code">SillyStamper</span> program, the images for
        the icons are
        read from resource files, the icons are placed into an array, and the array
        is used to construct a <span class="atype">JList&lt;Icon&gt;</span>. This is done by the following method:</p>


    <pre>private JList&lt;Icon&gt; createIconList() {

   String[] iconNames = new String[] {
      "icon5.png", "icon7.png", "icon8.png", "icon9.png", "icon10.png", 
      "icon11.png", "icon24.png", "icon25.png", "icon26.png", "icon31.png", 
      "icon33.png", "icon34.png"
   };              // Array containing resource file names for the icon images.

   iconImages = new Image[iconNames.length];

   ClassLoader classLoader = getClass().getClassLoader();
   Toolkit toolkit = Toolkit.getDefaultToolkit();
   try {                        // Get the icon images from the resource files.
      for (int i = 0; i &lt; iconNames.length; i++) {
         URL imageURL = classLoader.getResource("stamper_icons/" + iconNames[i]);
         if (imageURL == null)
            throw new Exception();
         iconImages[i] = toolkit.createImage(imageURL);
      }
   }
   catch (Exception e) {
      iconImages = null;
      return null;
   }

   ImageIcon[] icons = new ImageIcon[iconImages.length];
   for (int i = 0; i &lt; iconImages.length; i++)  // Create the icons.
      icons[i] = new ImageIcon(iconImages[i]);
   
   JList&lt;Icon&gt; list = new JList&lt;Icon&gt;(icons);  // A list containing image icons.
   list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
   list.setSelectedIndex(0);   // First item in the list is currently selected.
   
   return list;
}</pre>


    <p>By default, the user can select any number of items in a list. A single item is
        selected by clicking on it. Multiple items can be selected by shift-clicking and
        by either control-clicking or meta-clicking (depending on the platform).
        In the <span class="code">SillyStamper</span> program, I wanted to restrict the selection so that only
        one item can be selected at a time. This restriction is imposed by calling</p>


    <pre>list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);</pre>


    <p>With this selection mode, when the user selects an item, the previously
        selected item, if any, is deselected. Note that the selection can be
        changed by the program by calling <span class="code">list.setSelectedIndex(itemNum)</span>.
        Items are numbered starting from zero. To find out the currently selected
        item in single selection mode, call <span class="code">list.getSelectedIndex()</span>.
        This returns the item number of the selected item, or <span class="code">-1</span> if
        no item is currently selected. If multiple selections are allowed,
        you can call <span class="code">list.getSelectedIndices()</span>, which returns
        an array of <span class="ptype">ints</span> that contains the item numbers of
        all selected items.</p>


    <p>Now, the list that you see on the screen is only the <i>view</i> aspect
        of the list. The <i>controller</i> consists of the listener objects that
        respond when the user clicks an item in the list. For its <i>model</i>,
        a <span class="classname">JList</span> uses an object of type <span class="classname">ListModel</span>.
        This is the object that knows the actual list of items. A model is
        defined not only by the data that it contains but by the set of operations
        that can be performed on the data. When a <span class="classname">JList</span> is
        constructed from an array of objects, the model that is used is very simple.
        The model can tell you how many items it contains and what those items are,
        but it can't do much else. In particular, there is no way to add items
        to the list or to delete items from the list! If you need that capability,
        you will have to use a different list model.</p>


    <p>The class <span class="classname">DefaultListModel</span> defines list models that
        support adding items to and removing items from the list. Like <span class="classname">JList</span>,
        it is a parameterized class. (Note that the
        list model that you get when you create a <span class="classname">JList</span> from
        an array is <b>not</b> of this type.) If <span class="code">dlmodel</span> is of type
        <span class="classname">DefaultListModel</span>, the following methods, among
        others, are defined:</p>


    <ul>

        <li>
            <span class="codedef">dlmodel.getSize()</span> -- returns the number of items.
        </li>

        <li>
            <span class="codedef">dlmodel.getElementAt(index)</span> -- returns the item at position
            <span class="code">index</span> in the list.
        </li>

        <li>
            <span class="codedef">dlmodel.addElement(item)</span> -- Adds <span class="code">item</span> to the
            end of the list; <span class="code">item</span> can be any <span class="classname">Object</span>.
        </li>

        <li>
            <span class="codedef">dlmodel.insertElementAt(item, index)</span> -- inserts the specified
            <span class="code">item</span> into the list at the specified <span class="code">index</span>; items that
            come
            after that position in the list are moved down to make room for the new item.
        </li>

        <li>
            <span class="codedef">dlmodel.setElementAt(item, index)</span> -- Replaces the item
            that is currently at position <span class="code">index</span> in the list with <span
                class="code">item</span>.
        </li>

        <li>
            <span class="codedef">dlmodel.remove(index)</span> -- removes the item at position <span
                class="code">index</span>
            in the list.
        </li>

        <li>
            <span class="codedef">dlmodel.removeAllElements()</span> -- removes everything from the list,
            leaving it empty.
        </li>

    </ul>


    <p>To use a modifiable <span class="atype">JList&lt;T&gt;</span>, you should create a
        <span class="atype">DefaultListModel&lt;T&gt;</span>, add any items to it that should be
        in the list initially, and pass it to the <span class="classname">JList</span>
        constructor. For example:</p>


    <pre>DefaultListModel&lt;String&gt; listModel;
JList&lt;String&gt; flavorList;
   
listModel = new DefaultListModel&lt;String&gt;();    // Create the model object.
   
listModel.addElement("Chocolate");     // Add items to the model.
listModel.addElement("Vanilla");
listModel.addElement("Strawberry");
listModel.addElement("Rum Raisin");
   
flavorList = new JList&lt;String&gt;(listModel);     // Create the list component.</pre>


    <p>By keeping a reference to the model around in an instance variable, you
        will be able to add and delete flavors as the program is running by calling
        the appropriate methods in <span class="code">listModel</span>. Keep in mind that
        changes that are made to the <i>model</i> will automatically be reflected
        in the <i>view</i>. Behind the scenes, when a list model is modified, it generates
        an event of type <span class="classname">ListDataEvent</span>. The <span class="classname">JList</span>
        registers itself with its model as a listener for these events, and it
        responds to an event by redrawing itself to reflect the changes in the
        model. The programmer doesn't have to take any extra action, beyond changing the model.</p>


    <p>By the way, the model for a <span class="classname">JList</span> actually has another
        part in addition to the <span class="classname">ListModel</span>:
        An object of type <span class="classname">ListSelectionModel</span>
        stores information about which items in the list are currently selected.
        When the model is complex, it's not uncommon to use several model objects to
        store different aspects of the state.</p>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="GUI2.4.3">13.4.3&nbsp;&nbsp;Tables and TableModels</a>
    </h3>


    <p>Like a <span class="classname">JList</span>, a <span class="classname">JTable</span> displays
        a collection of items to the user. However, tables are much more complicated
        than lists. Perhaps the most important difference is that it is possible for
        the user to edit items in the table. Table items are arranged in a grid
        of rows and columns. Each grid position is called a <span class="newword">cell</span> of
        the table. Each column can have a <span class="newword">header</span>, which
        appears at the top of the column and contains a name for the column.</p>


    <p>It is easy to create a <span class="classname">JTable</span> from an array
        that contains the names of the columns and a two-dimensional array that
        contains the items that go into the cells of the table. As an
        example, the sample program <span class="sourceref"><a
                href="../source/chapter13/StatesAndCapitalsTableDemo.java">StatesAndCapitalsTableDemo.java</a></span>
        creates a table with two columns named "State" and "Capital City." The first
        column contains a list of the states of the United States and the second
        column contains the name of the capital city of each state. The table
        can be created as follows:</p>


    <pre>String[][] statesAndCapitals = new String[][] {
           { "Alabama", "Montgomery" },
           { "Alaska", "Juneau" },
           { "Arizona", "Phoenix" },
                .
                .
                .
           { "Wisconsin", "Madison" },
           { "Wyoming", "Cheyenne" }
        };

String[] columnHeads = new String[] { "State", "Capital City" };
   
JTable table = new JTable(statesAndCapitals, columnHeads);</pre>


    <p>Since a table does not come with its own scroll bars, it is almost
        always placed in a <span class="classname">JScrollPane</span> to make it possible
        to scroll the table. For example:</p>


    <pre>add( new JScrollPane(table), BorderLayout.CENTER );</pre>


    <p>The column headers of a <span class="classname">JTable</span> are not actually part of the table;
        they are in a separate component. But when you add the table to a
        <span class="classname">JScrollPane</span>, the column headers are automatically placed
        at the top of the pane.</p>


    <p>Using the default settings, the user can edit any cell in the table by
        clicking that cell. When editing a cell, the arrow keys
        can be used to move from one cell to another.
        The user can change the order of the columns by
        dragging a column header to a new position. The user can also change the
        width of the columns by dragging the line that separates neighboring
        column headers. You can try all this in
        <span class="sourceref"><a href="../source/chapter13/StatesAndCapitalsTableDemo.java">StatesAndCapitalsTableDemo.java</a></span>.
    </p>


    <p>Allowing the user to edit all entries in the table is not always appropriate;
        certainly it's not appropriate in the "states and capitals" example. A <span class="classname">JTable</span>
        uses an object of type <span class="classname">TableModel</span> to store information about the
        contents of the table. The model object is also responsible for deciding whether or not the
        user should be able to edit any given cell in the table. <span class="classname">TableModel</span>
        includes the method</p>


    <pre>public boolean isCellEditable(int rowNum, int columnNum)</pre>


    <p>where <span class="code">rowNum</span> and <span class="code">columnNum</span> are the position of a cell
        in the grid of rows and columns that make up the table.
        When the controller wants to know whether a certain cell is editable, it
        calls this method in the table model. If the return value is true, the user is allowed
        to edit the cell.</p>


    <p>The default model that is used when the table is created from an array of
        objects allows editing of all cells. For this model, the return value of
        <span class="code">isCellEditable()</span> is true in all cases.
        To make some cells non-editable, you have to provide a different model for the table.
        One way to do this is to create a subclass of <span class="classname">DefaultTableModel</span>
        and override the <span class="code">isCellEditable()</span> method. (<span
                class="classname">DefaultTableModel</span>
        and some other classes that are discussed in this section are defined in the
        package <span class="code">javax.swing.table</span>.) Here is how this might have been
        done in the "states and capitals" program to make all cells non-editable:</p>


    <pre>TableModel model = new DefaultTableModel(statesAndCapitals,columnHeads) {
   public boolean isCellEditable(int row, int col) {
      return false;
   }
};
JTable table = new JTable(model);</pre>


    <p>Here, an anonymous subclass of <span class="classname">DefaultTableModel</span> is
        created in which the <span class="code">isCellEditable()</span> method returns <span class="code">false</span>
        in
        all cases, and the model object that is created from that class is passed as a parameter
        to the <span class="classname">JTable</span> constructor.</p>


    <p>The <span class="classname">DefaultTableModel</span> class defines many methods
        that can be used to modify the table, including for example:
        <span class="code">setValueAt(item,rowNum,colNum)</span>
        to change the item in a given cell; <span class="code">removeRow(rowNum)</span> to delete a row; and
        <span class="code">addRow(itemArray)</span> to add a new row at the end of the table that contains
        items from the array <span class="code">itemArray</span>. Note that if the item
        in a given cell is set to <span class="code">null</span>, then that cell will be empty.
        Remember, again, that when you modify the model, the view is automatically
        updated to reflect the changes.</p>


    <p>In addition to the <span class="code">isCellEditable()</span> method, the table model method
        that you are most likely to want to override is <span class="code">getColumnClass()</span>,
        which is defined as</p>


    <pre>public Class&lt;?&gt; getColumnClass(columnNum)</pre>


    <p>The purpose of this method is to specify what kind of values are allowed in the
        specified column. The return value from this method is of type <span class="classname">Class</span>.
        (The "<span class="code">&lt;?&gt;</span>" is there for technical reasons having to do with generic programming.
        See <a href="../c10/s5.html">Section&nbsp;10.5</a>, but don't worry about understanding it here.)
        Although class objects have crept into this book in a few places -- in the discussion of
        <span class="classname">ClassLoaders</span> in <a href="../c13/s1.html#GUI2.1.3">Subsection&nbsp;13.1.3</a> for
        example -- this is
        the first time we have directly encountered the class named <span class="classname">Class</span>.
        An object of type <span class="classname">Class</span> represents a class. A <span
                class="classname">Class</span>
        object is usually obtained from the name of the class using expressions of the form
        "<span class="code">Double.class</span>" or "<span class="code">JTable.class</span>". If you want a three-column
        table in which the column types are <span class="classname">String</span>, <span class="classname">Double</span>,
        and <span class="classname">Boolean</span>, you can use a table model in which
        <span class="code">getColumnClass</span> is defined as:</p>


    <pre>public Class&lt;?&gt; getColumnClass(columnNum) {
   if (columnNum == 0)
      return String.class;
   else if (columnNum == 1)
      return Double.class;
   else
      return Boolean.class;
}</pre>


    <p>The table will call this method and use the return value to decide how
        to display and edit items in the table. For example, if a column is specified
        to hold <span class="classname">Boolean</span> values, the cells in that column will be displayed and
        edited as check boxes. For numeric types, the table will not accept
        illegal input when the user types in the value. (It is possible to change
        the way that a table edits or displays items. See the methods
        <span class="code">setDefaultEditor()</span> and <span class="code">setDefaultRenderer()</span>
        in the <span class="classname">JTable</span> class.)</p>


    <p>As an alternative to using a subclass of <span class="classname">DefaultTableModel</span>,
        a custom table model can also be defined using a subclass of <span class="classname">AbstractTableModel</span>.
        Whereas <span class="classname">DefaultTableModel</span> provides a lot of predefined functionality,
        <span class="classname">AbstractTableModel</span> provides very little. However, using
        <span class="classname">AbstractTableModel</span> gives you the freedom to represent the table
        data any way you want. The sample program <span class="sourceref"><a
                href="../source/chapter13/ScatterPlotTableDemo.java">ScatterPlotTableDemo.java</a></span>
        uses a subclass of <span class="classname">AbstractTableModel</span> to define the model for a
        <span class="classname">JTable</span>. In this program, the table has three columns. The
        first column holds a row number and is not editable. The other columns hold values
        of type <span class="classname">Double</span>; these two columns represent the x- and y-coordinates
        of points in the plane. The points themselves are graphed in a "scatter plot" next
        to the table. Initially, the program fills in the first six points with random values.
        Here is a picture of the program, with the x-coordinate in row 5 selected for
        editing:</p>


    <p align="center">
        <img src="scatter-plot-demo.png" width="570" height="324" alt="User inputs xy-points with a JTable"></p>


    <p>Note, by the way, that in this program, the scatter plot can be considered to be
        a view of the table model, in the same way that the table itself is. The scatter
        plot registers itself as a listener with the model, so that it will receive notification
        whenever the model changes. When that happens, the scatter plot redraws itself to
        reflect the new state of the model. It is an important property of the MVC pattern
        that several views can share the same model, offering alternative presentations of the
        same data. The views don't have to know about each other or communicate with each other except
        by sharing the model. Although I didn't do it in this program, it would even be
        possible to add a controller to the scatter plot view. This could let the user
        add a point by clicking the mouse on the scatter plot
        or drag a point to change its coordinates. The controller would update the table
        model, based on the user actions. Since the scatter plot
        and table share the same model, the values displayed in the table would automatically change to
        match.</p>


    <p>Here is the definition of the class that defines the model in the scatter plot
        program. All the methods in this class must be defined in any subclass of
        <span class="classname">AbstractTableModel</span> except for <span class="code">setValueAt()</span>,
        which only has to be defined if the table is modifiable.</p>


    <pre>/**
 * This class defines the TableModel that is used for the JTable in this
 * program.  The table has three columns.  Column 0 simply holds the
 * row number of each row.  Column 1 holds the x-coordinates of the
 * points for the scatter plot, and Column 2 holds the y-coordinates.
 * The table has 25 rows.  No support is provided for adding more rows.
 */
private class CoordInputTableModel extends AbstractTableModel {
   
   private Double[] xCoord = new Double[25];  // Data for Column 1.
   private Double[] yCoord = new Double[25];  // Data for Column 2.
        // Initially, all the values in the array are null, which means
        // that all the cells are empty.
   
   public int getColumnCount() {  // Tells caller how many columns there are.
      return 3;
   }

   public int getRowCount() {  // Tells caller how many rows there are.
      return xCoord.length;
   }

   public Object getValueAt(int row, int col) {  // Get value from cell.
      if (col == 0)
         return (row+1);        // Column 0 holds the row number.
      else if (col == 1)
         return xCoord[row];    // Column 1 holds the x-coordinates.
      else
         return yCoord[row];    // Column 2 holds the y-coordinates.
   }

   public Class&lt;?&gt; getColumnClass(int col) {  // Get data type of column.
      if (col == 0)
         return Integer.class;
      else
         return Double.class;
   }

   public String getColumnName(int col) {  // Returns a name for column header.
      if (col == 0)
         return "Num";
      else if (col == 1)
         return "X";
      else
         return "Y";
   }

   public boolean isCellEditable(int row, int col) { // Can user edit cell?
      return col &gt; 0;
   }
   
   public void setValueAt(Object obj, int row, int col) { 
         // (This method is called by the system if the value of the cell
         // needs to be changed because the user has edited the cell.
         // It can also be called to change the value programmatically.
         // In this case, only columns 1 and 2 can be modified, and the data
         // type for obj must be Double.  The method fireTableCellUpdated()
         // has to be called to send an event to registered listeners to
         // notify them of the modification to the table model.)
      if (col == 1) 
         xCoord[row] = (Double)obj;
      else if (col == 2)
         yCoord[row] = (Double)obj;
      fireTableCellUpdated(row, col);
   }
   
}  // end nested class CoordInputTableModel</pre>


    <p>In addition to defining a custom table model, I customized the appearance of the
        table in several ways. Because this involves changes to the view, most of the changes
        are made by calling methods in the <span class="classname">JTable</span> object. For example,
        since the default height of the cells was too small for my
        taste, I called <span class="code">table.setRowHeight(25)</span> to increase the height.
        To make lines appear between the rows and columns, I found that I had to call
        both <span class="code">table.setShowGrid(true)</span> and <span
                class="code">table.setGridColor(Color.BLACK)</span>.
        Some of the customization has to be done to other objects. For example, to
        prevent the user from changing the order of the columns by dragging the column
        headers, I had to use</p>


    <pre>table.getTableHeader().setReorderingAllowed(false);</pre>


    <p>Tables are quite complex, and I have only discussed a part of the
        table API here. Nevertheless, I hope that you have learned enough to
        start using them and to learn more about them on your own.</p>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="GUI2.4.4">13.4.4&nbsp;&nbsp;Documents and Editors</a>
    </h3>


    <p>As a final example of complex components, we look briefly at <span class="classname">JTextComponent</span>
        and its subclasses. A <span class="classname">JTextComponent</span> displays text that can,
        optionally, be edited by the user. Two subclasses, <span class="classname">JTextField</span> and
        <span class="classname">JTextArea</span>, were introduced in <a href="../c6/s5.html#GUI1.6.4">Subsection&nbsp;6.5.4</a>.
        But the real complexity comes in another subclass, <span class="classname">JEditorPane</span>,
        that supports display and editing of styled text. This allows features such as boldface
        and italic. A <span class="classname">JEditorPane</span> can even work with basic HTML
        documents.</p>


    <p>It is almost absurdly easy to write a simple web browser program using a
        <span class="classname">JEditorPane</span> (although the program that you get can
        only handle basic web pages and does a pretty bad job on many modern web pages).
        This is done in the sample program
        <span class="sourceref"><a href="../source/chapter13/SimpleWebBrowser.java">SimpleWebBrowser.java</a></span>. In
        this program, the user enters
        the URL of a web page, and the program tries to load and display the web page
        at that location. A <span class="classname">JEditorPane</span> can handle pages with
        content type "text/plain", "text/html", and "text/rtf". (The content type
        "text/rtf" represents styled or "rich text format" text. URLs and
        content types were covered in <a href="../c11/s4.html#IO.4.1">Subsection&nbsp;11.4.1</a>.) If <span
                class="code">editPane</span>
        is of type <span class="classname">JEditorPane</span> and <span class="code">url</span> is of type
        <span class="classname">URL</span>, then the statement "<span class="code">editPane.setPage(url);</span>"
        is sufficient to load the page and display it. Since this can generate an
        exception, the following method is used in <span class="sourceref"><a
                href="../source/chapter13/SimpleWebBrowser.java">SimpleWebBrowser.java</a></span>
        to display a page:</p>


    <pre>private void loadURL(URL url) {
   try {
      editPane.setPage(url);
   }
   catch (Exception e) {
      editPane.setContentType("text/plain"); // Set pane to display plain text.
      editPane.setText( "Sorry, the requested document was not found\n"
            +"or cannot be displayed.\n\nError:" + e);
   }
}</pre>


    <p>An HTML document can include links to other pages. When the user clicks on a link, the
        web browser should go to the linked page. A <span class="classname">JEditorPane</span> does
        not do this automatically, but it does generate an event of type <span class="classname">HyperLinkEvent</span>
        when the user clicks a link (provided that the edit pane has been set to be
        non-editable by the user). A program can register a listener for such events and
        respond by loading the new page.</p>


    <p>There are a lot of web pages that a <span class="classname">JEditorPane</span> won't be able
        to display correctly, but it can be very useful in cases where you have control over
        the pages that will be displayed. A nice application is to distribute HTML-format
        help and information files with a program. The files can be stored as resource
        files in the jar file of the program, and a URL for a resource file can be obtained
        in the usual way, using the <span class="code">getResource()</span> method of a <span class="classname">ClassLoader</span>.
        (See <a href="../c13/s1.html#GUI2.1.3">Subsection&nbsp;13.1.3</a>.)</p>


    <p>It turns out, by the way, that <span class="sourceref"><a href="../source/chapter13/SimpleWebBrowser.java">SimpleWebBrowser.java</a></span>
        is a
        little too simple. A modified version, <span class="sourceref"><a
                href="../source/chapter13/SimpleWebBrowserWithThread.java">SimpleWebBrowserWithThread.java</a></span>,
        improves on the original by using a thread to load a page and by checking the
        content type of a page before trying to load it. It actually does work as a
        simple web browser. Try it!</p>


    <p>The model for a <span class="classname">JTextComponent</span> is an object of type
        <span class="classname">Document</span>. If you want to be notified of changes in the
        model, you can add a listener to the model using</p>


    <pre>textComponent.getDocument().addDocumentListener(listener)</pre>


    <p>where <span class="code">textComponent</span> is of type <span class="classname">JTextComponent</span>
        and <span class="code">listener</span> is of type <span class="classname">DocumentListener</span>. The
        <span class="classname">Document</span> class also has methods that make it easy to
        read a document from a file and write a document to a file. I won't discuss
        all the things you can do with text components here. For one more peek at their
        capabilities, see the sample program <span class="sourceref"><a href="../source/chapter13/SimpleRTFEdit.java">SimpleRTFEdit.java</a></span>,
        a very minimal editor for files that contain styled text of type "text/rtf."</p>


    <hr class="break">
    <h3 class="subsection_title">
        <a name="GUI2.4.5">13.4.5&nbsp;&nbsp;Custom Components</a>
    </h3>


    <p>Java's standard component classes are usually all you need to construct a user
        interface. At some point, however, you might need a component that Java doesn't provide.
        In that case, you can write your own component class, building on one of the
        components that Java does provide. We've already done this, actually, every
        time we've written a subclass of the <span class="classname">JPanel</span> class to use as a drawing
        surface. A <span class="classname">JPanel</span> is a blank slate. By defining a subclass, you can
        make it show any picture you like, and you can program it to respond in any way
        to mouse and keyboard events. Sometimes, if you are lucky, you don't need such
        freedom, and you can build on one of Java's more sophisticated component
        classes.</p>


    <p>For example, suppose I have a need for a "stopwatch" component. When the
        user clicks on the stopwatch, I want it to start timing. When the user clicks
        again, I want it to display the elapsed time since the first click. The textual
        display can be done with a <span class="classname">JLabel</span>, but we want
        a <span class="classname">JLabel</span> that
        can respond to mouse clicks. We can get this behavior by defining a
        <span class="classname">StopWatchLabel</span> component as a subclass of the <span
                class="classname">JLabel</span> class. A
        <span class="classname">StopWatchLabel</span> object will listen for mouse clicks on itself. The first
        time the user clicks, it will change its display to "Timing..." and remember
        the time when the click occurred. When the user clicks again, it will check the
        time again, and it will compute and display the elapsed time. (Of course, I
        don't necessarily have to define a subclass. I could use a regular label in my
        program, set up a listener to respond to mouse events on the label, and let the
        program do the work of keeping track of the time and changing the text displayed
        on the label. However, by writing a new class, I have something that can be
        <b>reused</b> in other projects. I also have all the code involved in the stopwatch
        function collected together neatly in one place. For more complicated
        components, both of these considerations are very important.)</p>


    <p>The <span class="classname">StopWatchLabel</span> class is not very hard to write. I need an instance
        variable to record the time when the user starts the stopwatch. Times in Java
        are measured in milliseconds and are stored in variables of type <span class="ptype">long</span>
        (to allow for very large values). In the <span class="code">mousePressed()</span> method, I need
        to know whether the timer is being started or stopped, so I need a <span class="ptype">boolean</span>
        instance variable, <span class="code">running</span>, to keep track of this aspect of the component's state.
        There
        is one more item of interest: How do I know what time the mouse was clicked?
        The method <span class="code">System.currentTimeMillis()</span> returns the current time. But
        there can be some delay between the time the user clicks the mouse and the time
        when the <span class="code">mousePressed()</span> routine is called. To make my stopwatch as
        accurate as possible, I don't want to know the
        current time. I want to know the exact time when the mouse was pressed. When I
        wrote the <span class="classname">StopWatchLabel</span> class, this need sent me on a search in the Java
        documentation. I found that if <span class="code">evt</span> is an object of type
        <span class="classname">MouseEvent</span>, then the function <span class="code">evt.getWhen()</span> returns the
        time when the event occurred. I call this function in the
        <span class="code">mousePressed()</span> routine to determine the exact time when the user
        clicked on the label. The complete <span class="code">StopWatch</span> class is rather short:</p>


    <pre>import java.awt.event.*;
import javax.swing.*;

/**
 * A custom component that acts as a simple stop-watch.  When the user clicks
 * on it, this component starts timing.  When the user clicks again,
 * it displays the time between the two clicks.  Clicking a third time
 * starts another timer, etc.  While it is timing, the label just
 * displays the message "Timing....".
 */
public class StopWatchLabel extends JLabel implements MouseListener {

   private long startTime;   // Start time of timer.
                             //   (Time is measured in milliseconds.)

   private boolean running;  // True when the timer is running.

   /**
    * Constructor sets initial text on the label to
    * "Click to start timer." and sets up a mouse listener
    * so the label can respond to clicks.
    */
   public StopWatchLabel() {
      super("  Click to start timer.  ", JLabel.CENTER);
      addMouseListener(this);
   }
   
   
   /**
    * Tells whether the timer is currently running.
    */
   public boolean isRunning() {
      return running;
   }
   
   
   /**
    * React when the user presses the mouse by starting or stopping
    * the timer and changing the text that is shown on the label.
    */
   public void mousePressed(MouseEvent evt) {
      if (running == false) {
            // Record the time and start the timer.
         running = true;
         startTime = evt.getWhen();  // Time when mouse was clicked.
         setText("Timing....");
      }
      else {
            // Stop the timer.  Compute the elapsed time since the
            // timer was started and display it.
         running = false;
         long endTime = evt.getWhen();
         double seconds = (endTime - startTime) / 1000.0;
         setText("Time: " + seconds + " sec.");
      }
   }
   
   public void mouseReleased(MouseEvent evt) { }
   public void mouseClicked(MouseEvent evt) { }
   public void mouseEntered(MouseEvent evt) { }
   public void mouseExited(MouseEvent evt) { }

}</pre>


    <p>Don't forget that since <span class="classname">StopWatchLabel</span> is a subclass of <span class="classname">JLabel</span>,
        you can do anything with a <span class="classname">StopWatchLabel</span> that you can do with a
        <span class="classname">JLabel</span>. You can add it to a container. You can set its font,
        foreground color, and background color. You can set the text that it displays
        (although this would interfere with its stopwatch function). You can even add a
        <span class="classname">Border</span> if you want.</p>


    <p>Let's look at one more example of defining a custom component. Suppose that -- for
        no good reason whatsoever -- I want a component that acts like a
        <span class="classname">JLabel</span> except that it displays its text in mirror-reversed form. Since
        no standard component does anything like this, the <span class="classname">MirrorText</span> class
        is defined as a subclass of <span class="classname">JPanel</span>. It has a constructor that
        specifies the text to be displayed and a <span class="code">setText()</span> method that changes
        the displayed text. The <span class="code">paintComponent()</span> method draws the text
        mirror-reversed, in the center of the component. This uses techniques discussed
        in <a href="../c13/s1.html#GUI2.1.1">Subsection&nbsp;13.1.1</a> and <a href="../c13/s2.html#GUI2.2.1">Subsection&nbsp;13.2.1</a>.
        Information from a <span class="classname">FontMetrics</span>
        object is used to center the text in the component. The reversal is achieved by
        using an off-screen canvas. The text is drawn to the off-screen canvas, in the
        usual way. Then the image is copied to the screen with the following command,
        where <span class="code">OSC</span> is the variable that refers to the off-screen canvas,
        and <span class="code">width</span> and <span class="code">height</span> give the size of both the
        component and the off-screen canvas:</p>


    <pre>g.drawImage(OSC, width, 0, 0, height, 0, 0, width, height, null);</pre>


    <p>This is the version of <span class="code">drawImage()</span> that specifies corners of
        destination and source rectangles. The corner <span class="code">(0,0)</span> in <span class="code">OSC</span>
        is
        matched to the corner <span class="code">(width,0)</span> on the screen, while
        <span class="code">(width,height)</span> is matched to <span class="code">(0,height)</span>. This
        reverses the image left-to-right. Here is the complete class:</p>


    <pre>import java.awt.*;
import javax.swing.*;
import java.awt.image.BufferedImage;

/**
 * A component for displaying a mirror-reversed line of text.
 * The text will be centered in the available space.  This component
 * is defined as a subclass of JPanel.  It respects any background 
 * color, foreground color, and font that are set for the JPanel.
 * The setText(String) method can be used to change the displayed
 * text.  Changing the text will also call revalidate() on this
 * component.
 */
public class MirrorText extends JPanel {

   private String text; // The text displayed by this component.
   
   private BufferedImage OSC; // Holds an un-reversed picture of the text.

   /**
    * Construct a MirrorText component that will display the specified
    * text in mirror-reversed form.
    */
   public MirrorText(String text) {
      if (text == null)
         text = "";
      this.text = text;
   }
   
   /**
    * Change the text that is displayed on the label.
    * @param text the new text to display
    */
   public void setText(String text) {
      if (text == null)
         text = "";
      if ( ! text.equals(this.text) ) {
         this.text = text;  // Change the instance variable.
         revalidate();      // Tell container to recompute its layout.
         repaint();         // Make sure component is redrawn.
      }
   }
   
   /**
    * Return the text that is displayed on this component.
    * The return value is non-null but can be an empty string.
    */
   public String getText() {
      return text;
   }

   /**
    * The paintComponent method makes a new off-screen canvas, if necessary,
    * writes the text to the off-screen canvas, then copies the canvas onto
    * the screen in mirror-reversed form.
    */
   public void paintComponent(Graphics g) {
      int width = getWidth();
      int height = getHeight();
      if (OSC == null || width != OSC.getWidth() 
                          || height != OSC.getHeight()) {
         OSC = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);
      }
      Graphics OSG = OSC.getGraphics();
      OSG.setColor(getBackground());
      OSG.fillRect(0, 0, width, height);
      OSG.setColor(getForeground()); 
      OSG.setFont(getFont());
      FontMetrics fm = OSG.getFontMetrics(getFont());
      int x = (width - fm.stringWidth(text)) / 2;
      int y = (height + fm.getAscent() - fm.getDescent()) / 2;
      OSG.drawString(text, x, y);
      OSG.dispose();
      g.drawImage(OSC, width, 0, 0, height, 0, 0, width, height, null);
   }

   /**
    * Compute a preferred size that includes the size of the text, plus
    * a boundary of 5 pixels on each edge.
    */
   public Dimension getPreferredSize() {
      FontMetrics fm = getFontMetrics(getFont());
      return new Dimension(fm.stringWidth(text) + 10, 
            fm.getAscent() + fm.getDescent() + 10);
   }

}  // end MirrorText</pre>


    <p>This class defines the method "<span class="code">public Dimension
getPreferredSize()</span>". This method is called by a layout manager when it
        wants to know how big the component would like to be. Standard components come
        with a way of computing a preferred size. For a custom component based on a
        <span class="classname">JPanel</span>, it's a good idea to provide a custom preferred size.
        Every component has a method <span class="code">setPreferredSize()</span> that can
        be used to set the preferred size of the component.
        For our <span class="classname">MirrorText</span> component, however, the preferred size
        depends on the font and the text of the component, and these can change from time
        to time. We need a way to compute a preferred size on demand, based on the
        current font and text. That's what we do by defining a
        <span class="code">getPreferredSize()</span> method. The system calls this method when it wants
        to know the preferred size of the component. In response, we can compute the
        preferred size based on the current font and text.</p>


    <p>The <span class="classname">StopWatchLabel</span> and <span class="classname">MirrorText</span> classes define
        components.
        Components don't stand on their own. You have to add them to a panel or other
        container. The sample program <span class="sourceref"><a href="../source/chapter13/CustomComponentTest.java">CustomComponentTest.java</a></span>
        demonstrates using a <span class="classname">MirrorText</span> and a
        <span class="classname">StopWatchLabel</span> component, which
        are defined by the source code files <span class="sourceref"><a href="../source/chapter13/MirrorText.java">MirrorText.java</a></span>
        and
        <span class="sourceref"><a href="../source/chapter13/StopWatchLabel.java">StopWatchLabel.java</a></span>.</p>


    <p>In this program, the two custom components and a button are added to a
        panel that uses a <span class="classname">FlowLayout</span> as its layout manager,
        so the components are not arranged very neatly.
        If you click the button labeled "Change Text in this Program",
        the text in all the components will be changed. You can also
        click on the stopwatch label to start and stop the stopwatch. When you do any
        of these things, you will notice that the components will be rearranged to take
        the new sizes into account. This is known as "validating" the container. This
        is done automatically when a standard component changes in some way that
        requires a change in preferred size or location. This may or may not be the
        behavior that you want. (Validation doesn't always cause as much disruption as
        it does in this program. For example, in a <span class="classname">GridLayout</span>, where all the
        components are displayed at the same size, it will have no effect at all. I
        chose a <span class="classname">FlowLayout</span> for this example to make the effect more obvious.)
        When the text is changed in a <span class="classname">MirrorText</span> component,
        there is no automatic validation of its container.
        A custom component such as <span class="classname">MirrorText</span> must call the
        <span class="code">revalidate()</span> method to indicate that the container that contains the
        component should be validated. In the <span class="classname">MirrorText</span> class,
        <span class="code">revalidate()</span> is called in the <span class="code">setText()</span> method.</p>


</div>
<hr>
<div align="right">
    <small>
        [ <a href="s3.html">Previous Section</a> |
        <a href="s5.html">Next Section</a> |
        <a href="index.html">Chapter Index</a> |
        <a href="../index.html">Main Index</a> ]
    </small>
</div>
</body>
</html>
